## 多元运算  

> 译注：syntax与grammar 虽然都可以翻译为语法，但是还是有区别的：(经查询总结)  
> - syntax 也有人会译作句法，相比于grammar 更倾向于机器理解，grammar 更像是自然语言  
> - syntax 的表示范围要小于grammar  
> 
> 本文中的语法都是指syntax

当我在早上醒来，不禁思考一个问题：“为什么学习一门新的技术会如此艰难？”  
我并不认为困难仅仅来自于知识本身。其中一个重要原因是：我们花费了大量的时间和精力在阅读与观察上，却无暇顾及实践应用。就拿游泳来说，我们可以花很长时间阅读教材、与教练交流经验、观看教学视频，但是第一次下水时，仍然会像石头一样下沉。
纸上得来终觉浅，绝知此事要躬行。所以我在[第一章](http://ruslanspivak.com/lsbasi-part1/)和[第二章](http://ruslanspivak.com/lsbasi-part2/)设置了一些练习来帮助训练。当然，后面还会有一大波习题正在袭来。我保证:)  

迄今为止，我们已经学会了诸如"7 + 3"、"12-9"二元加减法。今天我们就将讨论，如何使我们的计算器支持像"7 - 3 + 2 - 1"这样的任意位数的加减法运算。  
我们可以用下面的`语法图(syntax diagram)`来表示本文中的计算器：  
![lsbasi_part3_syntax_diagram.png](img/03/lsbasi_part3_syntax_diagram.png)  

什么是语法图？语法图就是对一种编程语言语法规则的示意图。通俗来讲，通过语法图，我们可以直观地看出哪些语句是合法的，哪些语句是非法的。  
语法图通俗易懂：只要跟随箭头指示的路径往下走就行了。有限路径代表着选择；有些路径代表着循环。  
我们可以按顺序来阅读上面的语法图：一个`term``(本文中就是一个整数)`后面选择性地跟着一个`加号`或者`减号`(也可以不跟任何东西)，`+/-`后面再跟一个整数，然后选择性地绕回来后面再跟着运算符和整数，如此往复。  
使用语法图有两个目的：  

- 图形化展示一种编程语言的(syntax)定义  
- 通过跟随简单的语法规则，沿语法图的路径编码。可以帮助我们写出自己的解析器  

我们前面已经掌握了如何将`token`流识别为短语的过程，也就是`解析(parsing)`或`语法分析(syntax analysis)`。编译器或解释器负责解析工作的部分也被称为`解析器(parser)`或`语法分析器(syntax analyzer)`。
根据上面的语法图，我们可以得到下面的表达式是合法的：  

- 3  
- 3 + 4  
- 7 - 3 + 2 - 1  

这些语法规则类似于`Python`命令，和一般的编程语言不太像，我们可以启动`Python`的解释器来比较一下：  

```python
>>> 3
3
>>> 3 + 4
7
>>> 7 - 3 + 2 - 1
5
```  

不出所料。  
表达式"3 + "是非法表达式，因为加号后面必须要跟一个`term(整数)`，这就是一个语法错误。不信可以试一试：  

```python
>>> 3 +
  File "<stdin>", line 1
    3 +
      ^
SyntaxError: invalid syntax
```  

能用`Python`来验证固然是极好的，但我们是否可以根据上图构建解释器然后再做测试？  

我们知道，在前面([第一章](http://ruslanspivak.com/lsbasi-part1/)和[第二章](http://ruslanspivak.com/lsbasi-part2/))`expr()`方法扮演着解析器和解释器的角色。再啰嗦一句：解析器确保token流的结构符合语法规则；在解析完成后解释器进行相关计算并返回结果。  
下面的代码，就是参照语法图编写的。语法图中的方框`term`变成了`term()`方法来解析整数，`expr()`就是语法图的执行流程：  

```python
def term(self):
    self.eat(INTEGER)

def expr(self):
    # 将输入的第一个token 设置为当前token
    self.current_token = self.get_next_token()

    self.term()
    while self.current_token.type in (PLUS, MINUS):
        token = self.current_token
        if token.type == PLUS:
            self.eat(PLUS)
            self.term()
        elif token.type == MINUS:
            self.eat(MINUS)
            self.term()
```  

我们可以看到`expr()`首先会调用`term()`方法，随后紧跟着一个可以 **执行0次或多次** 的`while`循环。循环内部解析器将基于token的做出选择(执行加法还是减法)。可以在这块多花些时间来梳理清楚从语法图到代码之间的转换过程。  
解析器本身并不会执行(解释)任何东西，它只会默默无闻地识别表达式(或者抛出异常)，所以还需要给`expr()`添加解释器的代码：  

```python
def term(self):
    """返回整型token的值"""
    token = self.current_token
    self.eat(INTEGER)
    return token.value

def expr(self):
    """解析器 / 解释器 """
    # 将输入的第一个token 设置为当前token
    self.current_token = self.get_next_token()

    result = self.term()
    while self.current_token.type in (PLUS, MINUS):
        token = self.current_token
        if token.type == PLUS:
            self.eat(PLUS)
            result = result + self.term()
        elif token.type == MINUS:
            self.eat(MINUS)
            result = result - self.term()

    return result
```  

因为解释器需要执行表达式，所以`term()`方法需要返回整型token 的值，而`expr()`方法则在适当的地方增加算术运算，并返回计算结果。尽管代码很直接，但我还是建议多花点时间取学习(*译注：最好能在白纸上跟着语法图一步一步地走两遍*)。  

下面我们一起看一下完整代码：  

```python
# Token 类型
#
# EOF (end-of-file) token 表示输入结束
INTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'


class Token(object):
    def __init__(self, type, value):
        # token 类型: INTEGER 整数, PLUS +, MINUS -, or EOF 结束
        self.type = type
        # token 值: 正整数, '+', '-', or None
        self.value = value

    def __str__(self):
        """实例的字符串表示

        例如:
            Token(INTEGER, 3)
            Token(PLUS, '+')
        """
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()


class Interpreter(object):
    def __init__(self, text):
        # 输入字符串, 例如： "3 + 5", "12 - 5 + 3", etc
        self.text = text
        # self.pos 用来指示 self.text 中字符的位置
        self.pos = 0
        # 当前的token 对象
        self.current_token = None
        self.current_char = self.text[self.pos]

    ##########################################################
    # 词法分析器部分                                          #
    ##########################################################
    def error(self):
        raise Exception('I无效的语法(syntax)')

    def advance(self):
        """`pos`指针下移一位，获取新的当前字符"""
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # 到达字符串结束
        else:
            self.current_char = self.text[self.pos]

    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def integer(self):
        """从输入返回一个多位整数"""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def get_next_token(self):
        """词法分析器

        每次调用，将从输入字符串中提取出一个token
        """
        while self.current_char is not None:

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char == '+':
                self.advance()
                return Token(PLUS, '+')

            if self.current_char == '-':
                self.advance()
                return Token(MINUS, '-')

            self.error()

        return Token(EOF, None)

    ##########################################################
    # 解析器/解释器部分                                       #
    ##########################################################
    def eat(self, token_type):
        # 校验token 通过则将当前token指向下一个token，否则报异常
        if self.current_token.type == token_type:
            self.current_token = self.get_next_token()
        else:
            self.error()

    def term(self):
        """返回整数token的值"""
        token = self.current_token
        self.eat(INTEGER)
        return token.value

    def expr(self):
        """算术表达式的解析器/解释器"""
        # 当前token为输入字符串中的第一个token
        self.current_token = self.get_next_token()

        result = self.term()
        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            if token.type == PLUS:
                self.eat(PLUS)
                result = result + self.term()
            elif token.type == MINUS:
                self.eat(MINUS)
                result = result - self.term()

        return result


def main():
    while True:
        try:
            # Python3 中需要将 'raw_input' 替换为 'input'
            text = raw_input('calc> ')
        except EOFError:
            break
        if not text:
            continue
        interpreter = Interpreter(text)
        result = interpreter.expr()
        print(result)


if __name__ == '__main__':
    main()
```

将上面的代码保存为*calc3.py*或者直接从[GitHub](https://github.com/rspivak/lsbasi/blob/master/part3/calc3.py)上下载。运行一下，观察是否能正确处理之前语法图下面展示的数学运算。  
作者笔记本上的运行结果如下：  

```shell
$ python calc3.py
calc> 3
3
calc> 7 - 4
3
calc> 10 + 5
15
calc> 7 - 3 + 2 - 1
5
calc> 10 + 1 + 2 - 3 + 4 + 6 - 15
5
calc> 3 +
Traceback (most recent call last):
  File "calc3.py", line 147, in <module>
    main()
  File "calc3.py", line 142, in main
    result = interpreter.expr()
  File "calc3.py", line 123, in expr
    result = result + self.term()
  File "calc3.py", line 110, in term
    self.eat(INTEGER)
  File "calc3.py", line 105, in eat
    self.error()
  File "calc3.py", line 45, in error
    raise Exception('Invalid syntax')
Exception: Invalid syntax
```  

记得完成下面的联系哟，正如我开篇保证过的。  

![lsbasi_part3_exercises.png](img/03/lsbasi_part3_exercises.png)  

- 动手绘制乘法/除法运算的语法图，例如"7 * 4 / 2 * 3"  
- 修改代码，使之支持多元乘除法运算，以"7 * 4 / 2 * 3"为例  
- 从0编写多元加法器，以"7 - 3 + 2 - 1"。可以用任何熟悉的语言实现。带着下面这些概念去完成：词法分析器负责将输入转化为token；解析器负责从token流中识别特定的语法(syntax)结构；解释器负责执行表达式并返回运算结果。把这些模块组合在一起，花费一些时间将所学的只是变成可用的解释器。  

### 小测验  

1. 什么是语法图  
2. 什么是语法分析  
3. 什么是语法分析器  

看吧，你已经完成的今天的学习，辛苦啦。别忘了完成练习哦:)，我还会回来的！

下面是一些有用的参考资料：  

1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)  
2. [Writing Compilers and Interpreters: A Software Engineering Approach](http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=UCLGQTPIYSWYKRRM)  
3. [Modern Compiler Implementation in Java](http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=052182060X&linkCode=as2&tag=russblo0b-20&linkId=ZSKKZMV7YWR22NMW)  
4. [Modern Compiler Design](http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1461446988&linkCode=as2&tag=russblo0b-20&linkId=PAXWJP5WCPZ7RKRD)  
5. [Compilers: Principles, Techniques, and Tools (2nd Edition)](http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321486811&linkCode=as2&tag=russblo0b-20&linkId=GOEGDQG4HIHU56FQ)  

-----  

[阅读原文](https://ruslanspivak.com/lsbasi-part3/)  
第三章有许多重要的概念，(ง •_•)ง  
