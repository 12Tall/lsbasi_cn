04_ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•

ğŸ“… 2015-09-11  

ä¸€ç›´ä»¥æ¥ï¼Œä½ æ˜¯åœ¨æ¶ˆæåœ°é˜…è¯»è¿™äº›æ–‡ç« ï¼Œè¿˜æ˜¯èƒ½ç§¯æåœ°æŠ•å…¥å®è·µï¼Ÿæˆ‘ç”±è¡·åœ°å¸Œæœ›ä½ èƒ½ç§¯æåœ°åŠ¨æ‰‹å®è·µğŸ™‚  

å­”å­æ›°ï¼š~~*å­¦è€Œæ—¶ä¹ ä¹‹ï¼Œä¸äº¦è¯´ä¹?*~~

*é—»è€Œå¿˜ä¹‹*  
![LSBAWS_confucius_hear.png](../_resources/LSBAWS_confucius_hear.png)  

*è§è€Œè®°ä¹‹*
![LSBAWS_confucius_see.png](../_resources/LSBAWS_confucius_see.png)  

*è¡Œè€ŒçŸ¥ä¹‹*  
![LSBAWS_confucius_do.png](../_resources/LSBAWS_confucius_do.png)

åœ¨å‰é¢çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¼šäº†å¦‚ä½•è§£æ(è¯†åˆ«)å’Œè§£é‡Šä»»æ„å¤šåŠ å‡æ“ä½œçš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œä¾‹å¦‚:`7-3+2-1`ã€‚æˆ‘ä»¬è¿˜å­¦ä¼šäº†å¦‚ä½•ç»˜åˆ¶æŒ‡å®šè¯­æ³•çš„è¯­æ³•å›¾ã€‚  

ä»Šå¤©æˆ‘ä»¬å°†ç»§ç»­å­¦ä¹ ä»»æ„å¤šä¹˜é™¤æ³•æ“ä½œçš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œä¾‹å¦‚:`7*4/2*3`ã€‚æœ¬æ–‡è§„å®šé™¤æ³•ä¸ºæ•´æ•°é™¤æ³•ï¼Œä¾‹å¦‚:`9/4=2`ã€‚*è¯‘æ³¨ï¼šå…¶å®å°±æ˜¯æ±‚å•†è¿ç®—*  

æˆ‘ä¹Ÿä¼šè®²ä¸€äº›åœ¨å®šä¹‰ç¼–ç¨‹è¯­è¨€è¯­æ³•æ—¶å¹¿æ³›ç”¨åˆ°çš„æ¦‚å¿µï¼š***ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•(context-free grammars)*** æˆ–è€…***BNF (Backus-Naur Form)***ï¼Œ*è¯‘æ³¨ï¼šè¿™é‡Œè¯­æ³•ä¸æ˜¯syntaxï¼Œä¸¤è€…è¿˜æ˜¯æœ‰äº›åŒºåˆ«çš„ï¼Œsyntax ä¸€èˆ¬ç¿»è¯‘ä¸ºå¥æ³•*ã€‚æœ¬æ–‡æ— æ„ä½¿ç”¨çº¯ç²¹çš„[BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form)ï¼Œè€Œæ˜¯æ›´åƒ[EBNF](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form)ã€‚  

æˆ‘ä»¬ä½¿ç”¨ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•(Grammar)çš„åŸå› å¦‚ä¸‹ï¼š  
1. ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ä»¥ä¸€ç§éå¸¸ç®€æ´çš„å½¢å¼æŒ‡å®šäº†ä¸€ç§ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•ã€‚ä¸è¯­æ³•å›¾ä¸åŒï¼Œå®ƒéå¸¸ç´§å‡‘ã€‚æˆ‘ä»¬åé¢çš„æ–‡ç« ä¼šç”¨çš„æ›´å¤š  
2. ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•å¯ä»¥ç”¨äºå¤§å‹æ–‡æ¡£çš„è§£æ  
3. ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•æ˜¯éå¸¸å¥½çš„ç€æ‰‹ç‚¹ï¼Œå¦‚æœä½ è¦ä»å¤´å¼€å§‹ç¼–å†™è‡ªå·±çš„è¯­æ³•åˆ†æå™¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡éµå¾ªä¸€äº›ç®€å•çš„è§„åˆ™ï¼Œå°±å¯ä»¥å°†è¯­æ³•ç¿»è¯‘æˆä»£ç   
4. ç°åœ¨æœ‰å¾ˆå¤šè¢«ç§°ä¸ºè¯­æ³•åˆ†æå™¨ç”Ÿæˆå™¨çš„å·¥å…·ï¼Œå¯ä»¥å°†æŒ‡å®šçš„è¯­æ³•ç”Ÿæˆä¸ºè¯­æ³•åˆ†æå™¨ã€‚åœ¨åé¢çš„ç³»åˆ—ä¸­æˆ‘ä»¬ä¼šç»§ç»­æ¢è®¨è¿™äº›å·¥å…·  

ç°åœ¨æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä¸Šä¸‹æ–‡æ— å…³å…·ä½“é•¿ä»€ä¹ˆæ ·å­å§ã€‚  
ä¸‹é¢çš„è¯­æ³•å¯ä»¥æè¿°å½¢å¦‚`7*4/2*3` çš„ç®—æœ¯è¡¨è¾¾å¼(æ­¤è¡¨è¾¾å¼åªæ˜¯è¯­æ³•å¯ä»¥è¡¨ç¤ºçš„ä¼—å¤šå­é›†ä¸­çš„ä¸€ä¸ªå…ƒç´ )ã€‚ 
![lsbasi_part4_bnf1.png](../_resources/lsbasi_part4_bnf1.png)

ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ç”±ä¸€ç³»åˆ—çš„è§„åˆ™ç»„æˆï¼Œä»¥ä¸Šå›¾ä¸ºä¾‹ï¼Œè¯­æ³•ä¸­å°±åŒ…å«ä¸¤æ¡è§„åˆ™ï¼š  
![lsbasi_part4_bnf2.png](../_resources/lsbasi_part4_bnf2.png)

æ¯æ¡è¯­æ³•è§„åˆ™çš„å·¦è¾¹æ˜¯ä¸€ä¸ª**éç»ˆæ­¢ç¬¦**ï¼Œç§°ä¸º**è§„åˆ™å¤´**æˆ–è€…**å·¦è¾¹**ï¼›å³è¾¹æ˜¯ç”±ä¸€ç³»åˆ—**ç»ˆæ­¢ç¬¦**å’Œ/æˆ–**éç»ˆæ­¢ç¬¦**ç»„æˆçš„è§„åˆ™ä½“ï¼Œä¹Ÿè¢«ç§°ä¸º**å³è¾¹**ã€‚  
![lsbasi_part4_bnf3.png](../_resources/lsbasi_part4_bnf3.png)

åœ¨ä¸Šé¢çš„è¯­æ³•ä¸­ï¼Œåƒ`MUL`ã€`DIV` å’Œ`INTEGER` è¿™æ ·çš„`Token` è¢«ç§°ä¸º**ç»ˆæ­¢ç¬¦**ã€‚åƒ`expr` å’Œ`factor` è¢«ç§°ä¸º**éç»ˆæ­¢ç¬¦**ã€‚éç»ˆæ­¢ç¬¦ä¸€èˆ¬ç”±ä¸€ç³»åˆ—ç»ˆæ­¢ç¬¦å’Œ/æˆ–éç»ˆæ­¢ç¬¦æ„æˆã€‚*è¯‘æ³¨ï¼šè¿™é‡Œå°±å¯ä»¥çœ‹å‡ºé€’å½’çš„å½±å­äº†*  
![lsbasi_part4_bnf4.png](../_resources/lsbasi_part4_bnf4.png)

ç¬¬ä¸€æ¡è§„åˆ™çš„è§„åˆ™å¤´è¢«ç§°ä¸º**èµ·å§‹ç¬¦**ã€‚æœ¬è¯­æ³•ä¸­çš„èµ·å§‹ç¬¦æ˜¯`expr`ã€‚  
![lsbasi_part4_bnf5.png](../_resources/lsbasi_part4_bnf5.png)

æˆ‘ä»¬å¯ä»¥æŒ‰ç…§å¦‚ä¸‹è§„åˆ™å»è§£è¯»`expr`: ç”±ä¸€ä¸ª`factor` åé¢è·Ÿç€0 ä¸ªæˆ–å¤šä¸ª **"ç”±`*` æˆ–`/` å’Œä¸€ä¸ª`factor` ç»„æˆçš„ç»“æ„"** ç»„æˆã€‚  
è‡³äº`factor`ï¼Œæœ¬æ–‡ä¸­çš„`factor` å°±æ˜¯ä¸€ä¸ªæ•´æ•°ã€‚  

ä¸‹é¢ç®€å•ä»‹ç»ä¸€ä¸‹è¯­æ³•ä¸­å„è¿ç®—ç¬¦çš„æ„ä¹‰ï¼š  
- `|` æˆ–è¿ç®—ã€‚`(MUL|DIV)` è¡¨ç¤º`MUL` æˆ–è€…`DIV`  
- `(...)` è¡¨ç¤ºä¸€ä¸ªç»„
- `(...)*` è¡¨ç¤ºæ­¤ç»„å°†é‡å¤0 æ¬¡æˆ–å¤šæ¬¡  

å¦‚æœä½ ä¹‹å‰å­¦ä¹ è¿‡æ­£åˆ™è¡¨è¾¾å¼ï¼Œé‚£ä½ å¯¹ä¸Šé¢çš„ç¬¦å·ä¸€å®šä¸é™Œç”Ÿã€‚  

ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•æ ¹æ®å¥å¼å®šä¹‰è¯­è¨€ã€‚ä»¥ç®—æœ¯è¡¨è¾¾å¼ä¸ºä¾‹ï¼šé¦–å…ˆä»èµ·å§‹ç¬¦å¼€å§‹ï¼Œç„¶åä¸æ–­åœ°å°†éç»ˆæ­¢ç¬¦ç”±å¯¹åº”çš„ç»ˆæ­¢ç¬¦æ›¿æ¢ï¼Œç›´åˆ°ç”Ÿæˆä»…æœ‰ç»ˆæ­¢ç¬¦çš„å¥å­ã€‚è¿™äº›å¥å­(çš„å…¨é›†)å°±æ„æˆäº†è¯­è¨€ã€‚  

å¦‚æœä¸€ä¸ªè¯­æ³•ä¸èƒ½ç”ŸæˆæŸä¸ªç‰¹å®šçš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¯´è¯è¯­å‘ä¸æ”¯æŒè¯¥è¡¨è¾¾å¼ï¼Œåœ¨è¯†åˆ«è¯¥è¡¨è¾¾å¼æ—¶ï¼Œè¯­æ³•åˆ†æå™¨ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚  

ä¸‹é¢æ˜¯å‡ ä¸ªä¾‹å­ï¼Œä¾‹å¦‚:`3`
![lsbasi_part4_derive1.png](../_resources/lsbasi_part4_derive1.png)

`3*7`  
![lsbasi_part4_derive2.png](../_resources/lsbasi_part4_derive2.png)

`3*7/2`
![lsbasi_part4_derive3.png](../_resources/lsbasi_part4_derive3.png)

ç†è®ºçŸ¥è¯†æœ‰ç‚¹å¤šäº†~  

å½“æˆ‘ç¬¬ä¸€æ¬¡è§åˆ°ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•è¿™ä¸ªç§‘æŠ€æ„Ÿå¾ˆå¼ºçš„åè¯æ—¶ï¼Œæˆ‘æ˜¯ä¸€è„¸æ‡µé€¼çš„ï¼š 
![lsbasi_part4_bnf_hmm.png](../_resources/lsbasi_part4_bnf_hmm.png)  

ç»å¯¹æ²¡æœ‰ä¸€ä¸ä¸å–œæ‚¦ï¼Œæˆ‘ä¿è¯ç»å¯¹ä¸æ˜¯ä¸‹é¢è¿™ç§å¿ƒæƒ…ï¼š  
![lsbasi_part4_bnf_yes.png](../_resources/lsbasi_part4_bnf_yes.png)

æˆ‘ä»¬éœ€è¦èŠ±è´¹ä¸€äº›æ—¶é—´å»ç†Ÿæ‚‰è¿™ä¸ªæ¦‚å¿µã€å­¦ä¹ å®ƒçš„åŸç†ä»¥åŠå®ƒå’Œè¯­æ³•åˆ†æå™¨ä¸è¯æ³•åˆ†æå™¨çš„å…³ç³»ã€‚ä½†æ˜¯é•¿è¿œæ¥å¼€ï¼Œè¿™äº›åŠªåŠ›æ˜¯å€¼å¾—çš„ï¼Œå› ä¸ºåœ¨ç¼–è¯‘å™¨çš„å­¦ä¹ å’Œå®è·µä¸­å®ƒçš„ç”¨å¤„ä¼šéå¸¸å¹¿ã€‚æ‰€ä»¥ä¸ºä»€ä¹ˆä¸æ—©ç‚¹æŒæ¡å‘¢? ğŸ™‚  

è®©æˆ‘ä»¬è¯•ç€å°†è¯­æ³•è½¬åŒ–ä¸ºä»£ç å§ã€‚  

ä¸‹é¢æ˜¯ä¸€äº›è¯­æ³•åˆ°ä»£ç çš„è½¬åŒ–è§„åˆ™ï¼Œé€šè¿‡è¿™äº›è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å°†è¯­æ³•è½¬åŒ–ä¸ºä¸€ä¸ªè¯­æ³•åˆ†æå™¨:  
1. å¯¹äºä»»æ„ä¸€æ¡è§„åˆ™`R`ï¼Œå¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªåŒåå‡½æ•°`R()`ã€‚å‡½æ•°ä½“äº¦éµå¾ªç›¸åŒçš„åŸåˆ™
2. æˆ–è¿ç®—`(a1 | a2 | aN)` ç¿»è¯‘ä¸º`if-elif-else` è¯­å¥  
3. å¯é€‰åˆ†ç»„`(â€¦)*`è½¬åŒ–ä¸º`while`è¯­å¥  
4. æ¯ä¸ª`Token(T)`ï¼Œè½¬åŒ–ä¸º`eat` æ–¹æ³•: `eat(T)`ã€‚å¦‚æœ`eat()` ä¸å½“å‰token åŒ¹é…ï¼Œåˆ™ä»è¯æ³•åˆ†æå™¨è·å–ä¸‹ä¸€ä¸ªtoken èµ‹å€¼ç»™current_token å˜é‡  

çœ‹èµ·æ¥å¦‚ä¸‹å›¾æ‰€ç¤º:  
![lsbasi_part4_rules.png](../_resources/lsbasi_part4_rules.png)  

è®©æˆ‘ä»¬æŒ‰ç…§ä¸Šé¢çš„è§„åˆ™ä¸€æ­¥æ­¥åœ°ç¿»è¯‘ä¸ºä»£ç ã€‚  
```python
# 1. ç”±(1) çŸ¥ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªåŒåå‡½æ•°
def factor(self):
	# 2. ç”±(4) çŸ¥ï¼Œéœ€è¦åœ¨å‡½æ•°ä½“å»åŒ¹é…ä¸€ä¸ªtoken
	self.eat(INTEGER)
```

ä¸éš¾å§ï¼Œä¸‹é¢ç»§ç»­åˆ†æ`expr`:  
```python
# 1. ç”±(1) å®šä¹‰åŒåæ–¹æ³•
def expr(self):
	# 2. ç¬¬ä¸€ä¸ªfactor
	self.factor()
	
	# 3. ç”±(3) å¯é€‰åˆ†ç»„è½¬åŒ–ä¸ºwhile å¾ªç¯
	while self.current_token.type in (MUL, DIV):
        token = self.current_token
        # 4. ç”±(2) æˆ–è¿ç®—è½¬åŒ–ä¸ºé€‰æ‹©è¯­å¥
        if token.type == MUL:
        	# 5. åˆ†ç»„å†…æ˜¯ä¸€ä¸ªæ•´ä½“
            self.eat(MUL)
            self.factor()
        elif token.type == DIV:
            self.eat(DIV)
            self.factor()
```

å¤šèŠ±ç‚¹æ—¶é—´æ¥ææ¸…æ¥šæˆ‘æ˜¯å¦‚ä½•å°†è¯­æ³•è½¬åŒ–ä¸ºä»£ç çš„ã€‚  

ä¸ºæ–¹ä¾¿èµ·è§ï¼Œæˆ‘å°†ä¸Šè¿°ä»£ç è¿åŒä¸€ä¸ªè¯­æ³•åˆ†æå™¨ä¸è¯­æ³•åˆ†æå™¨ä¸€èµ·æ‰“åŒ…åˆ°`parser.py`ã€‚ä½ å¯ä»¥ç›´æ¥ä»[Github](https://github.com/rspivak/lsbasi/blob/master/part4/parser.py) ä¸‹è½½è¿è¡Œã€‚å®ƒæœ‰ä¸€ä¸ªäº¤äº’çª—å£ï¼Œä½ å¯ä»¥è¾“å…¥è¡¨è¾¾å¼çœ‹è¡¨è¾¾å¼æ˜¯å¦åˆæ³•ï¼šæ ¹æ®ä¸Šé¢è¯­æ³•æ„é€ çš„è¯­æ³•åˆ†æå™¨æ˜¯å¦èƒ½å¤Ÿè¯†åˆ«ã€‚  

ä¸‹é¢æ˜¯åœ¨æˆ‘ç”µè„‘ä¸Šè¿è¡Œçš„æƒ…å†µï¼š  

```python
$ python parser.py
calc> 3
calc> 3 * 7
calc> 3 * 7 / 2
calc> 3 *
Traceback (most recent call last):
  File "parser.py", line 155, in <module>
    main()
  File "parser.py", line 151, in main
    parser.parse()
  File "parser.py", line 136, in parse
    self.expr()
  File "parser.py", line 130, in expr
    self.factor()
  File "parser.py", line 114, in factor
    self.eat(INTEGER)
  File "parser.py", line 107, in eat
    self.error()
  File "parser.py", line 97, in error
    raise Exception('Invalid syntax')
Exception: Invalid syntax
```

è¯•ç€è¿è¡Œä¸€ä¸‹ã€‚æˆ‘ä¸ç¦æƒ³å†æä¸€ä¸‹è¯­æ³•å›¾ã€‚ä¸‹é¢æ˜¯`expr`è¯­æ³•å¯¹åº”çš„è¯­æ³•å›¾ã€‚
![lsbasi_part4_sd.png](../_resources/lsbasi_part4_sd.png)

æ˜¯æ—¶å€™ç»§ç»­æŒ–æ˜æˆ‘ä»¬æ–°è®¡ç®—å™¨çš„æºç äº†ã€‚ä¸‹é¢çš„ä»£ç å¯ä»¥å¤„ç†ä»»æ„å¤šå› æ•°çš„ä¹˜é™¤æ³•ã€‚ä½ ä¹Ÿå¯ä»¥å‘ç°æˆ‘å°†è¯­æ³•åˆ†æå™¨å•ç‹¬æˆä¸€ä¸ª`Lexer` ç±»ï¼Œå¹¶ä¸”æ–°çš„`Interpreter` ç±»ä¼šé‡‡ç”¨ä¸€ä¸ª`Lexer` å®ä¾‹åšå‚æ•°ï¼š  
```python
# Token types
#
# EOF (end-of-file) token is used to indicate that
# there is no more input left for lexical analysis
INTEGER, MUL, DIV, EOF = 'INTEGER', 'MUL', 'DIV', 'EOF'


class Token(object):
    def __init__(self, type, value):
        # token type: INTEGER, MUL, DIV, or EOF
        self.type = type
        # token value: non-negative integer value, '*', '/', or None
        self.value = value

    def __str__(self):
        """String representation of the class instance.

        Examples:
            Token(INTEGER, 3)
            Token(MUL, '*')
        """
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()


class Lexer(object):
    def __init__(self, text):
        # client string input, e.g. "3 * 5", "12 / 3 * 4", etc
        self.text = text
        # self.pos is an index into self.text
        self.pos = 0
        self.current_char = self.text[self.pos]

    def error(self):
        raise Exception('Invalid character')

    def advance(self):
        """Advance the `pos` pointer and set the `current_char` variable."""
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # Indicates end of input
        else:
            self.current_char = self.text[self.pos]

    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def integer(self):
        """Return a (multidigit) integer consumed from the input."""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def get_next_token(self):
        """Lexical analyzer (also known as scanner or tokenizer)

        This method is responsible for breaking a sentence
        apart into tokens. One token at a time.
        """
        while self.current_char is not None:

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char == '*':
                self.advance()
                return Token(MUL, '*')

            if self.current_char == '/':
                self.advance()
                return Token(DIV, '/')

            self.error()

        return Token(EOF, None)


class Interpreter(object):
    def __init__(self, lexer):
        self.lexer = lexer
        # set current token to the first token taken from the input
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')

    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then "eat" the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    def factor(self):
        """Return an INTEGER token value.

        factor : INTEGER
        """
        token = self.current_token
        self.eat(INTEGER)
        return token.value

    def expr(self):
        """Arithmetic expression parser / interpreter.

        expr   : factor ((MUL | DIV) factor)*
        factor : INTEGER
        """
        result = self.factor()

        while self.current_token.type in (MUL, DIV):
            token = self.current_token
            if token.type == MUL:
                self.eat(MUL)
                result = result * self.factor()
            elif token.type == DIV:
                self.eat(DIV)
                result = result / self.factor()

        return result


def main():
    while True:
        try:
            # To run under Python3 replace 'raw_input' call
            # with 'input'
            text = raw_input('calc> ')
        except EOFError:
            break
        if not text:
            continue
        lexer = Lexer(text)
        interpreter = Interpreter(lexer)
        result = interpreter.expr()
        print(result)


if __name__ == '__main__':
    main()
```

å°†ä¸Šé¢ä»£ç ä¿å­˜æˆ`calc4.py` æˆ–è€…ç›´æ¥ä»[Github](https://github.com/rspivak/lsbasi/blob/master/part4/calc4.py) ä¸‹è½½å¹¶è¿è¡ŒæŸ¥çœ‹ç»“æœã€‚  

ä¸‹é¢æ˜¯åœ¨æˆ‘è®¡ç®—æœºä¸Šè¿è¡Œçš„ä¾‹å­ï¼š
```python
$ python calc4.py
calc> 7 * 4 / 2
14
calc> 7 * 4 / 2 * 3
42
calc> 10 * 4  * 2 * 3 / 8
30
```

æˆ‘çŸ¥é“ä½ å·²ç»ç­‰ä¸åŠç»ƒä¹ äº†ğŸ™‚  
![lsbasi_part4_exercises.png](../_resources/lsbasi_part4_exercises.png)  

- å†™å‡ºå¤æ‚å››åˆ™è¿ç®—çš„ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ï¼Œä¾‹å¦‚`2 + 7 * 4`ï¼Œ`7 - 8 / 4`ï¼Œ`14 + 2 * 3 - 6 / 2` ç­‰ç­‰  
- å°†æ”¹è¯­æ³•ç¿»è¯‘ä¸ºç›¸åº”çš„è§£é‡Šå™¨  
- ä¼‘æ¯ä¸€ä¸‹  

## è‡ªæ£€  

ç‰¢è®°ä»Šå¤©æ‰€å­¦çš„å†…å®¹ï¼Œæ ¹æ®ä¸‹å›¾å›ç­”é—®é¢˜ï¼š  
![lsbasi_part4_exercises2.png](../_resources/lsbasi_part4_exercises2.png)  

1. ä»€ä¹ˆæ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•
2. ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ç”±å¤šå°‘è§„åˆ™
3. ä»€ä¹ˆæ˜¯ç»ˆæ­¢ç¬¦(åœ¨ä¸Šå›¾æŒ‡å‡ºå³å¯)
4. ä»€ä¹ˆéç»ˆæ­¢ç¬¦(åŒä¸Š)  
5. ä»€ä¹ˆæ˜¯è§„åˆ™å¤´(åŒä¸Š)  
6. ä»€ä¹ˆæ˜¯è§„åˆ™ä½“(åŒä¸Š)  
7. ä»€ä¹ˆæ˜¯èµ·å§‹ç¬¦

åˆ°æ­¤ä¸ºæ­¢ï¼Œä»Šå¤©çš„ç†è®ºæœ‰ç‚¹å¤šï¼Œèƒ½åšæŒä¸‹æ¥çœŸçš„å¾ˆå‰å®³äº†ï¼

æ•¬è¯·å…³æ³¨æ–°çš„æ–‡ç« ï¼Œä¸è¦å¿˜è®°ç»ƒä¹ å“¦ï¼Œthey will do you goodã€‚  

ä»¥ä¸‹ä¹¦ç±å¯èƒ½ä¼šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š  

1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)  
2. [Writing Compilers and Interpreters: A Software Engineering Approach](http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=UCLGQTPIYSWYKRRM)  
3. [Modern Compiler Implementation in Java](http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=052182060X&linkCode=as2&tag=russblo0b-20&linkId=ZSKKZMV7YWR22NMW)  
4. [Modern Compiler Design](http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1461446988&linkCode=as2&tag=russblo0b-20&linkId=PAXWJP5WCPZ7RKRD)  
5. [Compilers: Principles, Techniques, and Tools (2nd Edition)](http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321486811&linkCode=as2&tag=russblo0b-20&linkId=GOEGDQG4HIHU56FQ)   

-----  
2020-06-22 09:55