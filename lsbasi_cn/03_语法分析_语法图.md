03_è¯­æ³•åˆ†æ_è¯­æ³•å›¾

ğŸ“… 2015-08-12  

æˆ‘ä»Šå¤©æ—©ä¸Šé†’æ¥é—®è‡ªå·±:"ä¸ºä»€ä¹ˆå­¦ä¹ æ–°æŠ€æœ¯ä¼šå¦‚æ­¤è‰°éš¾?"  

æˆ‘è®¤ä¸ºéš¾åº¦å¹¶ä¸åªåœ¨äºå·¥ä½œæœ¬èº«ã€‚è¿˜æœ‰ä¸€ä¸ªåŸå› ï¼Œå¤§æ¦‚å°±æ˜¯æˆ‘ä»¬èŠ±è´¹äº†å¤§é‡çš„æ—¶é—´åœ¨é˜…è¯»ï¼Œè€Œä¸æ˜¯å®è·µä¸Šã€‚ä»¥å­¦ä¹ æ¸¸æ³³ä¸ºä¾‹ï¼šæˆ‘ä»¬å¯ä»¥èŠ±è´¹å¤§é‡çš„æ—¶é—´é˜…è¯»æœ‰å…³ä¹¦ç±ã€è§‚çœ‹è§†é¢‘æ•™ç¨‹ã€å‘åˆ«äººè¯·æ•™ç»éªŒï¼Œä½†æ˜¯åœ¨ç¬¬ä¸€æ¬¡ä¸‹æ°´æ—¶ä»ç„¶ä¼šåƒçŸ³å¤´ä¸€æ ·ä¸‹æ²‰ã€‚  
ç»“æœå°±æ˜¯ï¼šå¯¹æŠ€æœ¯äº†è§£å¤šå°‘å¹¶ä¸é‡è¦ï¼Œå¿…é¡»è¦å°†æ‰€å­¦ä»˜è¯¸å®è·µæ‰èƒ½è½¬åŒ–ä¸ºæŠ€èƒ½ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨[01_åˆè¯†è§£é‡Šå™¨_æ„é€ ç®€å•çš„åŠ æ³•å™¨](../lsbasi_cn/01_%E5%88%9D%E8%AF%86%E8%A7%A3%E9%87%8A%E5%99%A8_%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8.md)å’Œ[02_è§£æå™¨_åŠ å‡æ³•è¿ç®—](../lsbasi_cn/02_%E8%A7%A3%E6%9E%90%E5%99%A8_%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97.md)è®¾ç½®äº†ä¸€äº›ç»ƒä¹ ã€‚å½“ç„¶ï¼Œä»Šå¤©æˆ‘ä»¬ä¼šæœ‰æ›´å¤šçš„ç»ƒä¹ çš„ã€‚ğŸ™‚  

è¨€å½’æ­£ä¼ ï¼Œå¼€å§‹ä»Šå¤©çš„æ­£é¢˜å§ã€‚  

ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†å¦‚ä½•å¤„ç†åŠ å‡æ³•çš„è¿ç®—ï¼Œä¾‹å¦‚ï¼š`7 + 3` æˆ–è€…`12 - 9`ã€‚ä»Šå¤©æˆ‘ä»¬å­¦ä¹ å¦‚ä½•è§£æ(è¯†åˆ«)å¹¶å¤„ç†åŒ…å«ä»»æ„å¤šä¸ªåŠ å‡è¿ç®—çš„è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼š`7 - 3 + 2 - 1`ã€‚  

æœ¬æ–‡ä¸­çš„ç®—æ•°è¡¨è¾¾å¼å¯ä»¥ç”¨ä¸‹é¢çš„è¯­æ³•å›¾å½¢è±¡åœ°è¡¨ç¤ºï¼š  

![lsbasi_part3_syntax_diagram.png](../_resources/c93775011e22446db9b3a30f7e130e7e.png)  

ä»€ä¹ˆæ˜¯è¯­æ³•å›¾? è¯­æ³•å›¾(syntax diagram)æ˜¯è¡¨ç¤ºè¯­æ³•è§„åˆ™çš„å›¾å½¢ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¯­æ³•å›¾è¡¨ç¤ºç¼–ç¨‹è¯­è¨€ä¸­å…è®¸ä½¿ç”¨ä»€ä¹ˆæ ·çš„è¯­å¥ã€‚  
è¯­æ³•å›¾å¾ˆå®¹æ˜“é˜…è¯»ï¼šæ²¿ç€ç®­å¤´æŒ‡ç¤ºçš„è·¯å¾„ã€‚æœ‰äº›è¡¨ç¤ºé€‰æ‹©ï¼Œæœ‰äº›è¡¨ç¤ºå¾ªç¯ã€‚  

æˆ‘ä»¬å¯ä»¥æŒ‰ç…§å¦‚ä¸‹çº¦å®šå»é˜…è¯»è¯­æ³•å›¾ï¼šä¸€ä¸ª`term` åé¢è·Ÿç€(å¯é€‰)ä¸€ä¸ªè¿ç®—ç¬¦å’Œå¦ä¸€ä¸ª`term`ï¼Œåé¢è·Ÿç€(å¯é€‰)ä¸€ä¸ªè¿ç®—ç¬¦å’Œ`term`ï¼Œå¦‚æ­¤å¾ªç¯ã€‚æœ¬æ–‡ä¸­çš„`term` å°±æ˜¯ä¸€ä¸ªæ•´æ•°ã€‚*è¯‘æ³¨ï¼šä¸çŸ¥é“`term` æ˜¯å¦å¯ä»¥ç¿»è¯‘æˆçŸ­è¯­æˆ–è€…è¯ç»„ï¼Œåº”è¯¥å¯ä»¥ç†è§£ä¸ºå…·æœ‰å®Œæ•´è¯­æ³•æ„ä¹‰çš„å•ä½*  

ç»˜åˆ¶è¯­æ³•å›¾æœ‰ä¸¤ä¸ªç›®çš„ï¼š  
- å°†æŒ‡å®šç¼–ç¨‹è¯­è¨€(çš„è¯­æ³•)å›¾å½¢åŒ–å±•ç¤º  
- é€šè¿‡ç®€å•çš„è§„åˆ™éå†è¯­æ³•å›¾ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬ç¼–å†™è§£æå™¨  

æ ¹æ®ä¸Šé¢çš„è¯­æ³•å›¾ï¼Œä¸‹è¾¹çš„ç®—æœ¯è¡¨è¾¾å¼æ˜¯æœ‰æ•ˆçš„ï¼š  

- 3  
- 3 + 4
- 7 - 3 + 2 - 1 

ä¸åŒç¼–ç¨‹è¯­è¨€å¯¹ç®—æœ¯è¡¨è¾¾å¼çš„è¯­æ³•è§„åˆ™ç±»ä¼¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡Python çš„shell æ¥æµ‹è¯•ï¼š  

```python
>>> 3
3
>>> 3 + 4
7
>>> 7 - 3 + 2 - 1
5
```  
è¿ç®—æ­£å¸¸  

è¡¨è¾¾å¼`3 +` æ˜¯æ— æ•ˆçš„ç®—æœ¯è¿ç®—ï¼Œå› ä¸ºæ ¹æ®ä¸Šé¢çš„è¯­æ³•å›¾ï¼Œè¿ç®—ç¬¦åé¢å¿…é¡»è¦è·Ÿéšä¸€ä¸ª`term` å¦åˆ™å°±æ˜¯è¯­æ³•é”™è¯¯ã€‚æˆ‘ä»¬å¯ä»¥åœ¨Python ä¸­å†æµ‹è¯•ä¸€ä¸‹ï¼š  
```python 
>>> 3 +
  File "<stdin>", line 1
    3 +
      ^
SyntaxError: invalid syntax
```

ä½¿ç”¨python æ¥éªŒè¯éå¸¸æ–¹ä¾¿ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„è¯­æ³•æ ‘ç¿»è¯‘æˆæˆ‘ä»¬è§£é‡Šèµ·çš„ä»£ç æ¥éªŒè¯ä¸€ä¸‹ï¼Œä¸ä¹ŸæŒºå¥½çš„å—ï¼Ÿ  

åœ¨ä¹‹å‰çš„æ–‡ç« ([01_åˆè¯†è§£é‡Šå™¨_æ„é€ ç®€å•çš„åŠ æ³•å™¨](../lsbasi_cn/01_%E5%88%9D%E8%AF%86%E8%A7%A3%E9%87%8A%E5%99%A8_%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8.md)å’Œ[02_è§£æå™¨_åŠ å‡æ³•è¿ç®—](../lsbasi_cn/02_%E8%A7%A3%E6%9E%90%E5%99%A8_%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97.md))ä¸­ï¼Œ`expr()` æ–¹æ³•æ˜¯è§£æä¸ç¿»è¯‘æ‰§è¡Œçš„åœ°æ–¹ã€‚è§£æå™¨åªæ˜¯è¯†åˆ«æŒ‡å®šçš„è¯­æ³•ç»“æ„ï¼Œä¸€æ—¦æˆåŠŸè¯†åˆ«ä¾¿ä¼šå¯¹å…¶æ±‚å€¼ã€‚  
ä¸‹é¢çš„ä»£ç ç‰‡æ®µå±•ç¤ºäº†è¯­æ³•å›¾å¯¹åº”çš„è§£æå™¨ä»£ç ã€‚è¯­æ³•å›¾ä¸­çŸ©å½¢æ¡†`term` è¢«è½¬åŒ–ä¸ºäº†`term()` æ–¹æ³•ï¼Œè€Œ`expr()` æ–¹æ³•åˆ™éµå¾ªè¯­æ³•å›¾çš„æµç¨‹ï¼š  
```python
# term ç›®å‰åªæ˜¯æ•´æ•°
def term(self):
    self.eat(INTEGER)

def expr(self):
    # å…ˆå–ç¬¬ä¸€ä¸ªtoken ä¸ºå½“å‰token
    self.current_token = self.get_next_token()

    self.term()
    while self.current_token.type in (PLUS, MINUS):
        token = self.current_token
        if token.type == PLUS:
            self.eat(PLUS)
            self.term()
        elif token.type == MINUS:
            self.eat(MINUS)
            self.term()
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°`expr()` é¦–å…ˆè°ƒç”¨`term()`ã€‚ç„¶ååœ¨ä¹‹åçš„0 æ¬¡æˆ–å¤šæ¬¡å¾ªç¯ä¸­é‡å¤åŒ¹é…è¿ç®—ç¬¦ä¸ä¸‹ä¸€ä¸ª`term()`ã€‚è¿™é‡Œå¯ä»¥å¯¹ç…§ç€ä¸Šé¢çš„è¯­æ³•å›¾ä»”ç»†ç†è§£ä¸€ä¸‹ã€‚  

ä¸Šé¢è§£æå™¨æœ¬èº«å¹¶ä¸ä¼šç¿»è¯‘ä»»ä½•ä¸œè¥¿(ä¸è®¡ç®—ç»“æœ)ï¼šé»˜é»˜åœ°è¯†åˆ«è¡¨è¾¾å¼ï¼Œæˆ–è€…æŠ›å‡ºå¼‚å¸¸ã€‚æˆ‘ä»¬å¯ä»¥ç»™å®ƒæ·»åŠ ä¸€äº›ä»£ç ï¼Œè®©å®ƒå¯ä»¥æ‰§è¡Œç¿»è¯‘çš„å·¥ä½œï¼š  
```python
def term(self):
    token = self.current_token
    self.eat(INTEGER)
    # term() å°†è¿”å›æ•´æ•°å€¼
    return token.value

def expr(self):
    """Parser / Interpreter """
    # set current token to the first token taken from the input
    self.current_token = self.get_next_token()

    result = self.term()
    while self.current_token.type in (PLUS, MINUS):
        token = self.current_token
        # åŒ¹é…æ—¶åŒæ—¶è®¡ç®—
        # å› ä¸ºä¸æ¶‰åŠè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ï¼Œç›®å‰è¿™æ ·åšæ˜¯å¯ä»¥çš„
        if token.type == PLUS:
            self.eat(PLUS)
            result = result + self.term()
        elif token.type == MINUS:
            self.eat(MINUS)
            result = result - self.term()

    return result
```

å› ä¸ºè§£é‡Šå™¨éœ€è¦è®¡ç®—è¡¨è¾¾å¼çš„ç»“æœï¼Œ`term()` æ–¹æ³•éœ€è¦è¿”å›ä¸€ä¸ªæ•°å€¼ï¼Œå¹¶ä¸”`expr()` æ–¹æ³•ä¹Ÿè¢«ä¿®æ”¹ä¸ºå¯ä»¥æ‰§è¡ŒåŠ å‡è¿ç®—ï¼Œå¹¶æœ€ç»ˆè¿”å›è®¡ç®—ç»“æœã€‚å°½ç®¡ä»£ç å¾ˆç›´è§‚ï¼Œä½†æˆ‘è¿˜æ˜¯å»ºè®®å¤šéƒ½å‡ æ¬¡ï¼Œä»¥ä¾¿æ›´å¥½åœ°æŒæ¡ã€‚  

æ¥ä¸‹æ¥è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å®Œæ•´çš„ä»£ç å§  

æ–°ç‰ˆæœ¬è®¡ç®—å™¨çš„æºç å¯ä»¥å¤„ç†åˆæ³•çš„ç®—æœ¯è¡¨è¾¾å¼ï¼šåŒ…å«ä»»æ„å¤šçš„æ•´æ•°åŠ å‡æ³•è¿ç®—ï¼š  

```python
# Token types
#
# EOF (end-of-file) token is used to indicate that
# there is no more input left for lexical analysis
INTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'


class Token(object):
    def __init__(self, type, value):
        # token type: INTEGER, PLUS, MINUS, or EOF
        self.type = type
        # token value: non-negative integer value, '+', '-', or None
        self.value = value

    def __str__(self):
        """String representation of the class instance.

        Examples:
            Token(INTEGER, 3)
            Token(PLUS, '+')
        """
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()


class Interpreter(object):
    def __init__(self, text):
        # client string input, e.g. "3 + 5", "12 - 5 + 3", etc
        self.text = text
        # self.pos is an index into self.text
        self.pos = 0
        # current token instance
        self.current_token = None
        self.current_char = self.text[self.pos]

    ##########################################################
    # Lexer code                                             #
    ##########################################################
    def error(self):
        raise Exception('Invalid syntax')

    def advance(self):
        """Advance the `pos` pointer and set the `current_char` variable."""
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # Indicates end of input
        else:
            self.current_char = self.text[self.pos]

    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def integer(self):
        """Return a (multidigit) integer consumed from the input."""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def get_next_token(self):
        """Lexical analyzer (also known as scanner or tokenizer)

        This method is responsible for breaking a sentence
        apart into tokens. One token at a time.
        """
        while self.current_char is not None:

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char == '+':
                self.advance()
                return Token(PLUS, '+')

            if self.current_char == '-':
                self.advance()
                return Token(MINUS, '-')

            self.error()

        return Token(EOF, None)

    ##########################################################
    # Parser / Interpreter code                              #
    ##########################################################
    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then "eat" the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.get_next_token()
        else:
            self.error()

    def term(self):
        """Return an INTEGER token value."""
        token = self.current_token
        self.eat(INTEGER)
        return token.value

    def expr(self):
        """Arithmetic expression parser / interpreter."""
        # set current token to the first token taken from the input
        self.current_token = self.get_next_token()

        result = self.term()
        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            if token.type == PLUS:
                self.eat(PLUS)
                result = result + self.term()
            elif token.type == MINUS:
                self.eat(MINUS)
                result = result - self.term()

        return result


def main():
    while True:
        try:
            # To run under Python3 replace 'raw_input' call
            # with 'input'
            text = raw_input('calc> ')
        except EOFError:
            break
        if not text:
            continue
        interpreter = Interpreter(text)
        result = interpreter.expr()
        print(result)


if __name__ == '__main__':
    main()
```

å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸º`calc3.py` æˆ–è€…ç›´æ¥ä»[Github](https://github.com/rspivak/lsbasi/blob/master/part3/calc3.py) ä¸Šä¸‹è½½è¿è¡Œã€‚çœ‹å®ƒèƒ½å¦å¤„ç†ä¸Šé¢è¯­æ³•å›¾ä¸­å¾—å‡ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚  

ä¸‹é¢æ˜¯åœ¨æˆ‘ç¬”è®°æœ¬ç”µè„‘ä¸Šçš„ä¸€äº›æµ‹è¯•ä¾‹å­ï¼š  
```python
$ python calc3.py
calc> 3
3
calc> 7 - 4
3
calc> 10 + 5
15
calc> 7 - 3 + 2 - 1
5
calc> 10 + 1 + 2 - 3 + 4 + 6 - 15
5
calc> 3 +
Traceback (most recent call last):
  File "calc3.py", line 147, in <module>
    main()
  File "calc3.py", line 142, in main
    result = interpreter.expr()
  File "calc3.py", line 123, in expr
    result = result + self.term()
  File "calc3.py", line 110, in term
    self.eat(INTEGER)
  File "calc3.py", line 105, in eat
    self.error()
  File "calc3.py", line 45, in error
    raise Exception('Invalid syntax')
Exception: Invalid syntax
```

è¿˜è®°å¾—æˆ‘ä¸Šè¾¹æåˆ°çš„ç»ƒä¹ å—ï¼Ÿå°±æ˜¯ä¸‹é¢è¿™äº›ï¼š  

![lsbasi_part3_exercises.png](../_resources/537593f876604615b75dda6916ac5770.png)  

- ç»˜åˆ¶ä¹˜é™¤æ³•çš„è¯­æ³•å›¾ï¼Œå¦‚ï¼š`7 * 4 / 2 * 3`  
- ä¿®æ”¹æºç ï¼Œä½¿æˆ‘ä»¬çš„è§£é‡Šå™¨(åª)èƒ½å¤Ÿè®¡ç®—ä¹˜é™¤æ³•ï¼Œå¦‚ï¼š`7 * 4 / 2 * 3`  
- ä»å¤´å†™ä¸€ä¸ªå¯ä»¥å®Œæˆå¦‚`7 - 3 + 2 - 1` çš„è§£é‡Šå™¨ã€‚å¯ä»¥ä½¿ç”¨ä»»ä½•ä½ å–œæ¬¢çš„è¯­è¨€ï¼Œä½†æ˜¯ä¸è¦çœ‹ä¸Šé¢çš„ä¾‹å­ã€‚åœ¨å†™çš„æ—¶å€™å¯ä»¥æƒ³è±¡ä¸€ä¸ªè§£é‡Šå™¨åŒ…å«çš„ç»„ä»¶ï¼š`Lexer` è¯æ³•åˆ†æå™¨ï¼Œå°†æºä»£ç æ‹†åˆ†ä¸ºä¸€ç³»åˆ—çš„`Token`ï¼›`Paser` è§£æå™¨ä»`Token` ä¸­è¯†åˆ«ç‰¹å®šçš„ç»“æ„ï¼›å½“è§£æå™¨æˆåŠŸè¯†åˆ«è¡¨è¾¾å¼åè§£é‡Šå™¨ä¾¿ä¼šè¿”å›è®¡ç®—çš„ç»“æœã€‚å°†ä¸Šé¢çš„çŸ¥è¯†ç‚¹ä¸²åœ¨ä¸€èµ·ï¼ŒèŠ±äº›æ—¶é—´å°†æ‰€å­¦çš„çŸ¥è¯†è½¬åŒ–ä¸ºä¸€ä¸ªå¯ä»¥å·¥ä½œçš„è§£é‡Šå™¨ã€‚  

**è‡ªæ£€**  
1. ä»€ä¹ˆæ˜¯è¯­æ³•å›¾  
2. ä»€ä¹ˆæ˜¯è¯­æ³•åˆ†æ
3. ä»€ä¹ˆæ˜¯è¯­æ³•åˆ†æå™¨  

çœ‹å§ï¼Œä½ å·²ç»çœ‹å®Œäº†ã€‚æ„Ÿè°¢ä»Šå¤©çš„å…³æ³¨ï¼Œä¸è¦å¿˜è®°åšç»ƒä¹ å“¦:) æ•¬è¯·å…³æ³¨ä¸‹æ¬¡æ›´æ–°ã€‚

ä»¥ä¸‹ä¹¦ç±å¯èƒ½ä¼šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š  

1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)  
2. [Writing Compilers and Interpreters: A Software Engineering Approach](http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=UCLGQTPIYSWYKRRM)  
3. [Modern Compiler Implementation in Java](http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=052182060X&linkCode=as2&tag=russblo0b-20&linkId=ZSKKZMV7YWR22NMW)  
4. [Modern Compiler Design](http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1461446988&linkCode=as2&tag=russblo0b-20&linkId=PAXWJP5WCPZ7RKRD)  
5. [Compilers: Principles, Techniques, and Tools (2nd Edition)](http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321486811&linkCode=as2&tag=russblo0b-20&linkId=GOEGDQG4HIHU56FQ)   

-----  
2020-06-18 15:42