16_è¯†åˆ«è¿‡ç¨‹è°ƒç”¨   

ğŸ“… 2019-07-23  

> â€œå­¦å¦‚é€†æ°´è¡ŒèˆŸï¼Œä¸è¿›åˆ™é€€â€ â€”â€” ä¸­å›½è°šè¯­    

ä»Šå¤©æˆ‘ä»¬å°†è¦æ‰©å±•æˆ‘ä»¬çš„è§£é‡Šå™¨æ¥è¯†åˆ«è¿‡ç¨‹è°ƒç”¨ï¼ˆProcedure Callï¼‰ã€‚æˆ‘å¸Œæœ›ä½ å·²ç»é€šè¿‡å‰é¢çš„æ–‡ç« å¤§æ˜¾èº«æ‰‹ï¼Œå¹¶ä¸”å‡†å¤‡å¥½æ›´è¿›ä¸€æ­¥äº†ã€‚å­¦ä¹ è¯†åˆ«/è§£æè¿‡ç¨‹è°ƒç”¨æ˜¯æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨å‰çš„å…³é”®ä¸€æ­¥ï¼Œå…³äºå¦‚ä½•æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨ï¼Œåœ¨åé¢çš„æ–‡ç« ä¸­æˆ‘ä»¬ä¼šè¯¦ç»†å±•å¼€è¯´æ˜ã€‚  

ä»Šå¤©æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯è®©æˆ‘ä»¬çš„è§£é‡Šå™¨èƒ½å¤Ÿæ­£ç¡®è¯†åˆ«è¿‡ç¨‹è°ƒç”¨è¯­å¥ã€æ„é€ æ–°çš„æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹ã€ç”Ÿæˆæ­£ç¡®çš„æŠ½è±¡è¯­æ³•æ ‘ã€å¹¶ä¸”é¡ºåˆ©åœ°å®Œæˆè¯­ä¹‰åˆ†æã€‚  

ä»¥ä¸‹é¢Pascal ä»£ç ä¸ºä¾‹ï¼Œå…¶ä¸­åŒ…å«äº†ä¸€æ¡è¿‡ç¨‹è°ƒç”¨è¯­å¥`Alpha(3+5,7);`ï¼š  
![](../_resources/lsbasi_part16_img01.png)  

æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯è®©è§£é‡Šå™¨èƒ½æ­£ç¡®çš„è§£æç±»ä¼¼äºä¸Šé¢è¿™ç§ç¨‹åºçš„Pascal ä»£ç ã€‚  

ä¸€èˆ¬æˆ‘ä»¬å¼•å…¥æ–°çš„ç‰¹æ€§æ—¶ï¼Œéƒ½ä¼šå¸¦æ¥è®¸å¤šç›¸å…³ç»„ä»¶çš„æ”¹åŠ¨ï¼Œä¸‹é¢å°±è®©æˆ‘ä»¬ä¸€ä¸€å®ç°ã€‚  

## è¯­æ³•åˆ†æå™¨  
> è¯‘æ³¨ï¼šå› ä¸ºè¿‡ç¨‹è°ƒç”¨æ²¡æœ‰å¼•å…¥æ–°çš„Tokenï¼Œæ‰€ä»¥è¯æ³•åˆ†æéƒ¨åˆ†ä¸éœ€è¦å˜åŠ¨  

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ”¹åŠ¨è¯­æ³•åˆ†æå™¨ã€‚ä¸‹é¢æ˜¯éœ€è¦å˜åŠ¨çš„æ¸…å•ï¼š  
1. å¢åŠ æ–°çš„AST èŠ‚ç‚¹è¡¨ç¤ºè¿‡ç¨‹è°ƒç”¨ï¼›  
2. å¢åŠ æ–°çš„è¿‡ç¨‹è°ƒç”¨çš„è¯­æ³•è§„åˆ™ï¼Œå¹¶é€šè¿‡ä»£ç å®ç°ï¼›  
3. æ”¹è¿›`statement` è¯­æ³•è§„åˆ™ï¼Œä½¿å…¶åŒ…å«è¿‡ç¨‹è°ƒç”¨çš„å­è§„åˆ™ã€‚  

é¦–å…ˆæ˜¯ä¸ºè¿‡ç¨‹è°ƒç”¨åˆ›å»ºå•ç‹¬çš„AST èŠ‚ç‚¹ç±»`ProcedureCall`ï¼š  
```python
class ProcedureCall(AST):
    def __init__(self, proc_name, actual_params, token):
        self.proc_name = proc_name
        self.actual_params = actual_params  # a list of AST nodes
        self.token = token
```  
è¯¥ç±»çš„æ„é€ å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šè¿‡ç¨‹åã€å®å‚ã€å’Œ`Token`ã€‚ä»¥ä¸ŠåŒ…å«æŸä¸ªè¿‡ç¨‹è°ƒç”¨æ‰€éœ€çš„è¶³å¤Ÿçš„ä¿¡æ¯ã€‚  

å…¶æ¬¡æ˜¯æ·»åŠ æ–°çš„è¯­æ³•è§„åˆ™`proccall_statement`ï¼š  
```  
proccall_statement : ID LPAREN (expr (COMMA expr)*)? RPAREN
```  
ä¸‹é¢æ˜¯å¯¹åº”çš„è¯­æ³•å›¾ï¼š  
![](../_resources/lsbasi_part16_img02.png)  

ä»ä¸Šå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œè¿‡ç¨‹è°ƒç”¨æ˜¯è¿‡ç¨‹ååé¢è·Ÿç€ä¸€å¯¹æ‹¬å·ï¼Œæ‹¬å·ä¸­åŒ…å«é›¶ä¸ªæˆ–å¤šä¸ªå®å‚ã€‚ä¾‹å¦‚ï¼š  
```pascal  
Alpha();
Alpha(1);
Alpha(3 + 5, 7);
```  

ç•Œé™æ¥æˆ‘ä»¬é€šè¿‡æ·»åŠ `proccall_statement` æ–¹æ³•æ¥å®ç°ï¼š  
```python
def proccall_statement(self):
    """proccall_statement : ID LPAREN (expr (COMMA expr)*)? RPAREN"""
    token = self.current_token

    proc_name = self.current_token.value
    self.eat(TokenType.ID)
    self.eat(TokenType.LPAREN)
    actual_params = []
    if self.current_token.type != TokenType.RPAREN:
        node = self.expr()
        actual_params.append(node)

    while self.current_token.type == TokenType.COMMA:
        self.eat(TokenType.COMMA)
        node = self.expr()
        actual_params.append(node)

    self.eat(TokenType.RPAREN)

    node = ProcedureCall(
        proc_name=proc_name,
        actual_params=actual_params,
        token=token,
    )
    return node
```  
ç®€å•æ˜äº†ï¼Œè¯¥æ–¹æ³•è§£æä¸€ä¸ªè¿‡ç¨‹è°ƒç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ª`ProcedureCall` èŠ‚ç‚¹ã€‚  

æœ€åï¼Œæˆ‘ä»¬éœ€è¦æ”¹è¿›`statement` è¯­æ³•è§„åˆ™ï¼Œå·²åŒ…å«`proccall_statement` å­è§„åˆ™ï¼Œä¸‹é¢æ˜¯æ”¹è¿›åçš„è§„åˆ™ï¼š  
```
statement : compound_statement
          | proccall_statement
          | assignment_statement
          | empty
```  

ç°åœ¨æˆ‘ä»¬çš„é¢å‰æœ‰ä¸€ä¸ªéš¾é¢˜ï¼š`proccall_statement` å’Œ`assignment_statement` éƒ½æ˜¯ä»¥`Token<ID>` å¼€å¤´çš„ï¼Œè¯¥å¦‚ä½•åŒºåˆ†å®ƒä»¬å‘¢ï¼Ÿ  
```
proccall_statement : ID LPAREN (expr (COMMA expr)*)? RPAREN

assignment_statement : variable ASSIGN expr
variable: ID
```  

ä¾‹å¦‚åœ¨ä¸‹é¢ä¸¤å¥ä»£ç ä¸­ï¼Œå¤§å®¶éƒ½æ˜¯ä»¥`foo` å¼€å¤´ï¼š  
```pascal
foo();     { procedure call }
foo := 5;  { assignment }
```

æˆ‘ä»¬çš„è¯­æ³•åˆ†æå™¨åº”è¯¥å°†`foo();` è¯†åˆ«ä¸ºè¿‡ç¨‹è°ƒç”¨ï¼Œè€Œå°†`foo := 5;` è¯†åˆ«ä¸ºèµ‹å€¼è¯­å¥ã€‚æˆ‘ä»¬åº”è¯¥åšäº›ä»€ä¹ˆä»¥å®ç°è¿™ä¸ªåŠŸèƒ½å‘¢ï¼Ÿçœ‹è¿‡ç¨‹è°ƒç”¨çš„è¯­æ³•è§„åˆ™ï¼Œè¿‡ç¨‹ååé¢ç´§è·Ÿç€çš„æ˜¯å·¦æ‹¬å·`(`ï¼Œè€Œèµ‹å€¼è¯­å¥åˆ™æ˜¯`:`ï¼Œè€Œè¿™æ°æ°å°±æ˜¯æˆ‘ä»¬ç”¨äºåŒºåˆ†äºŒè€…çš„ä¾æ®ï¼š  
```python  
if (self.current_token.type == TokenType.ID and
    self.lexer.current_char == '('  
    # è¿™é‡Œè°ƒç”¨äº†è¯æ³•åˆ†æå™¨ï¼Œåé¢ä¼šæœ‰æ›´å¥½çš„åŠæ³•å—ï¼Ÿ
):
    node = self.proccall_statement()
elif self.current_token.type == TokenType.ID:
    node = self.assignment_statement()
```  

ä»ä¸Šé¢çš„ä»£ç çœ‹å‡ºï¼Œå¦‚æœå½“å‰`Token` æ˜¯`ID`ï¼Œè¯­æ³•åˆ†æå™¨å°†ä¼šæ£€æŸ¥ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ä¸æ˜¯`(`ï¼Œå¦‚æœæ˜¯åˆ™æ˜¯è¿‡ç¨‹è°ƒç”¨ï¼Œå¦åˆ™å°±æ˜¯èµ‹å€¼è¯­å¥ã€‚ä¸‹é¢æ˜¯å®Œæ•´ä»£ç ï¼š  
```python  
def statement(self):
    """
    statement : compound_statement
              | proccall_statement
              | assignment_statement
              | empty
    """
    if self.current_token.type == TokenType.BEGIN:
        node = self.compound_statement()
    elif (self.current_token.type == TokenType.ID and
          self.lexer.current_char == '('
    ):
        node = self.proccall_statement()
    elif self.current_token.type == TokenType.ID:
        node = self.assignment_statement()
    else:
        node = self.empty()
    return node
```  

So far so goodï¼Œæˆ‘ä»¬çš„è¯­æ³•åˆ†æå™¨å¯ä»¥è§£æè¿‡ç¨‹è°ƒç”¨äº†ã€‚éœ€è¦æä¸€ä¸‹çš„æ˜¯ï¼Œæˆ‘ä»¬çš„Pascal è¿‡ç¨‹ç›®å‰è¿˜æ²¡æœ‰è¿”å›å€¼ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨åœ¨ä¸‹é¢è¿™ç§è¡¨è¾¾å¼ä¸­ï¼š  
```pascal  
x := 10 * Alpha(3 + 5, 7);
```  

è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬åªåœ¨`statements` è§„åˆ™ä¸­åŠ å…¥`proccall_statement` çš„åŸå› ï¼Œåœ¨åé¢ç³»åˆ—ï¼Œæˆ‘ä»¬å­¦ä¹ Pascal å‡½æ•°çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šåœ¨è¡¨è¾¾å¼å’Œèµ‹å€¼è¯­å¥ä¸­å¼•å…¥è¿”å›å€¼çš„æ¦‚å¿µã€‚  
ä»¥ä¸Šå°±æ˜¯æ‰€æœ‰è¯­æ³•åˆ†æå™¨çš„å˜åŠ¨ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä¿®æ”¹è¯­ä¹‰åˆ†æå™¨ã€‚  

## è¯­ä¹‰åˆ†æå™¨  
å¯¹äºè¯­ä¹‰åˆ†æå™¨ï¼Œæˆ‘ä»¬åªéœ€è¦æ–°å¢ä¸€ä¸ª`visit_ProcedureCall` çš„æ–¹æ³•ï¼š  
```python
def visit_ProcedureCall(self, node):
    for param_node in node.actual_params:
        self.visit(param_node)
```  
è¯¥æ–¹æ³•ä¼šéå†å®å‚çš„é›†åˆï¼Œé€’å½’åœ°ã€‚å› ä¸ºå®å‚å¯ä»¥æ˜¯ä¸€ä¸ªAST å­æ ‘ã€‚ä»¥ä¸Šã€‚  

## è§£é‡Šå™¨  
è§£é‡Šå™¨çš„è§„åˆ™æ›´åŠ ç®€å•ï¼Œå› ä¸ºç›®å‰æˆ‘ä»¬å¹¶ä¸æ‰“ç®—æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨ï¼š  
```python
def visit_ProcedureCall(self, node):
    pass
```  

é€šè¿‡ä»¥ä¸Šæ”¹åŠ¨ï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨å¯ä»¥æ­£ç¡®è¯†åˆ«è¿‡ç¨‹è°ƒç”¨ï¼Œå¹¶åˆ›å»ºå¯¹åº”çš„æŠ½è±¡è¯­æ³•æ ‘äº†ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢ä»£ç åšæµ‹è¯•ï¼š   
```pascal  
program Main;

procedure Alpha(a : integer; b : integer);
var x : integer;
begin
   x := (a + b ) * 2;
end;

begin { Main }

   Alpha(3 + 5, 7);  { procedure call }

end.  { Main }
```  

ä»[GitHub](https://github.com/rspivak/lsbasi/tree/master/part16) ä¸‹è½½`part16.pas` å’Œ`spi.py` åœ¨å‘½ä»¤è¡Œè¿è¡Œï¼š  
```shell-session
$ python spi.py part16.pas
$ 
```  

æ²¡æœ‰æŠ¥é”™ï¼Œä½†æ˜¯å¼ºè¿«ç—‡è¡¨ç¤ºçœ‹èµ·æ¥ä¸èˆ’æœã€‚äºæ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡[genastdot.py](https://github.com/rspivak/lsbasi/tree/master/part16/genastdot.py) å°†ç”Ÿæˆçš„æŠ½è±¡è¯­æ³•æ ‘å¯è§†åŒ–ï¼š  
```shell-session  
$ python genastdot.py part16.pas > ast.dot && dot -Tpng -o ast.png ast.dot
```  
![](../_resources/lsbasi_part16_img03.png)  

èˆ’å¦ï¼å¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„æŠ½è±¡è¯­æ³•æ ‘åŒ…å«æœ‰ä¸€ä¸ª`ProcCall:Alpha` çš„è¿‡ç¨‹è°ƒç”¨èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹åˆåŒ…å«æœ‰ä¸¤ä¸ªå®å‚å­èŠ‚ç‚¹ï¼šå·¦è¾¹çš„æ˜¯è¡¨è¾¾å¼`3+5`ï¼Œå³è¾¹æ˜¯æ•´æ•°`7`ã€‚  

è‡³æ­¤ä»Šå¤©çš„ç›®æ ‡å°±å®Œæˆäº†ï¼šå½“æˆ‘ä»¬çš„è§£é‡Šå™¨é‡åˆ°è¿‡ç¨‹è°ƒç”¨è¯­å¥æ—¶ï¼Œå°±ä¼šå°†å®ƒè§£æä¸º`ProcCall` èŠ‚ç‚¹ï¼Œå¹¶æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ï¼Œè¯­ä¹‰åˆ†æå™¨ä¹Ÿä¼šæŒ‰éƒ¨å°±ç­åœ°æ£€æŸ¥ã€æ²¡æœ‰å¼‚å¸¸æŠ›å‡ºã€‚  

## ç»ƒä¹   
![](../_resources/lsbasi_part16_img04.png)  

ä¸Šé¢çš„è¯­ä¹‰æ£€æŸ¥éƒ¨åˆ†ç¼ºå°‘äº†å®å‚çš„ç±»å‹ä¸æ•°é‡çš„æ£€æŸ¥ã€‚æŠ›å¼€ç±»å‹æ£€æŸ¥ä¸è°ˆï¼ŒPascal çš„è¿‡ç¨‹è°ƒç”¨åªæ¥å—ä¸å½¢å‚æ•°é‡ç›¸ç­‰çš„å®å‚ï¼Œä»¥ä¸‹é¢è¿‡ç¨‹å®šä¹‰ä¸ºä¾‹ï¼š  
```pascal
procedure Alpha(a : integer; b : integer);
var x : integer;
begin
   x := (a + b ) * 2;
end;
```  
è¯¥è¿‡ç¨‹åªæ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œè¯•å›¾ä¼ å…¥å…¶ä»–æ•°é‡çš„å‚æ•°æ—¶å‡ä¼šå‡ºé”™ï¼š  
```pascal
Alpha();          { 0 arguments â€”> ERROR }
Alpha(1);         { 1 argument  â€”> ERROR }
Alpha(1, 2, 3);   { 3 arguments â€”> ERROR }
```  

ä½ å¯ä»¥åœ¨[solution.txt](https://github.com/rspivak/lsbasi/tree/master/part16) ä¸­æ‰¾åˆ°è§£å†³æ–¹æ¡ˆï¼Œä½†åœ¨æ­¤ä¹‹å‰ï¼Œæœ€å¥½äº²è‡ªåŠ¨æ‰‹è§£å†³ä¸€ä¸‹ã€‚  

ä»¥ä¸Šå°±æ˜¯ä»Šå¤©çš„å…¨éƒ¨å†…å®¹ã€‚ä¸‹ä¸€ç« æˆ‘ä»¬å°†ä¼šå­¦ä¹ å¦‚ä½•è§£é‡Šæ‰§è¡Œè¿‡ç¨‹è°ƒç”¨ï¼Œä¸­é—´ä¼šç”¨åˆ°è°ƒç”¨æ ˆï¼ˆCall Stackï¼‰å’Œæ´»åŠ¨è®°å½•ï¼ˆActivation Recordï¼‰çš„æ¦‚å¿µï¼Œä¼šå¾ˆåˆºæ¿€çš„ã€‚æ•¬è¯·æœŸå¾…ï¼Œå†è§ï¼:)  

## å‚è€ƒèµ„æ–™  
ç­¹åˆ’æœ¬æ–‡æ—¶çš„å‚è€ƒèµ„æ–™ï¼š  
1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)     
2. [Writing Compilers and Interpreters: A Software Engineering Approach](https://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=542d1267e34a529e0f69027af20e27f3)    
3. [Free Pascal Reference guide](https://www.freepascal.org/docs-html/current/ref/ref.html)

-----  
2022-07-12 23:57