02_è§£æå™¨_åŠ å‡æ³•è¿ç®—

ğŸ“… 2015-07-03  

åœ¨ã€ŠThe 5 Elements of Effective Thinkingã€‹ä¸€ä¹¦ä¸­ï¼Œä½œè€…Burger å’ŒStarbird åˆ†äº«äº†ä¸€åˆ™å…³äºå›½é™…å°å·å¤§å¸ˆTony Plog ä¸¾åŠåŸ¹è®­ç­çš„æ•…äº‹ï¼šåˆšå¼€å§‹çš„æ—¶å€™ï¼Œå­¦å‘˜ä»¬éå¸¸å®Œç¾åœ°æ¼”å¥äº†å¤æ‚çš„æ›²å­ï¼Œä½†ä¹‹ååœ¨è¢«è¦æ±‚æ¼”å¥åŸºç¡€çš„éŸ³ç¬¦æ—¶ï¼Œå£°éŸ³å´æ˜¾å¾—éå¸¸å¹¼ç¨šã€‚æœ€ç»ˆå¤§å¸ˆTony Plog åŒæ ·ä¹Ÿæ¼”å¥äº†ç®€å•çš„éŸ³ç¬¦ï¼Œå´ä¸æ¯«æ²¡æœ‰å¹¼ç¨šçš„æ„Ÿè§‰ã€‚åŒºåˆ«å¾ˆæ˜æ˜¾ï¼ŒTony è§£é‡Šåˆ°ï¼šç†Ÿç»ƒæŒæ¡ç®€å•çš„éŸ³ç¬¦å¯ä»¥è®©ä¹æ‰‹æ›´å¥½åœ°æŒæ§å¤æ‚çš„æ›²å­ã€‚è¿™åˆ™æ•…äº‹å‘Šè¯‰æˆ‘ä»¬ï¼Œæƒ³è¦æœ‰æ‰€æˆå°±ï¼Œå¿…é¡»å…ˆä¸“æ³¨äºç†Ÿç»ƒæŒæ¡æœ€ç®€å•ã€åŸºç¡€çš„æƒ³æ³•ã€‚  

ä¸Šé¢çš„æ•…äº‹å¯¹äºè½¯ä»¶å¼€å‘æ¥è¯´ä¹ŸåŒæ ·é€‚ç”¨ã€‚å®ƒæ—¶åˆ»æé†’æˆ‘ä»¬ä¸è¦è½»è§†ç®€å•ã€åŸºç¡€å·¥ä½œçš„é‡è¦æ€§ï¼Œå°½ç®¡æœ‰æ—¶å€™çœ‹èµ·æ¥åƒæ˜¯åœ¨åšæ— ç”¨åŠŸã€‚èƒ½å¤Ÿç†Ÿç»ƒè¿ç”¨å·¥å…·ã€æ¡†æ¶å›ºç„¶é‡è¦ï¼Œä½†æ˜¯çŸ¥æ™“å®ƒä»¬èƒŒåçš„åŸç†ä¹ŸåŒæ ·é‡è¦ã€‚æ­£å¦‚Ralph Waldo Emerson(è‰¾é»˜ç”Ÿ) æ‰€è¯´ï¼š  
> "å¦‚æœä½ åªä¼šæ–¹æ³•ï¼Œåè€Œä¼šè¢«æ–¹æ³•æŸç¼šï¼›ä½†å¦‚æœä½ æŒæ¡äº†åŸç†ï¼Œä½ å°±å¯ä»¥åˆ›é€ è‡ªå·±çš„çš„æ–¹æ³•"  

å…³äºè¿™ä¸€ç‚¹å°±è¯´è¿™ä¹ˆå¤šï¼Œä¸‹é¢è®©æˆ‘ä»¬ç»§ç»­å­¦ä¹ ç¼–è¯‘å™¨å’Œè§£é‡Šå™¨å§ã€‚  

ä»Šå¤©æˆ‘ä»¬ä¼šæ‰©å±•[01_åˆè¯†è§£é‡Šå™¨_æ„é€ ç®€å•çš„åŠ æ³•å™¨](../lsbasi_cn/01_%E5%88%9D%E8%AF%86%E8%A7%A3%E9%87%8A%E5%99%A8_%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8.md)æ‰€å†™çš„è®¡ç®—å™¨ï¼Œæ˜¯æŒ‡èƒ½å¤Ÿå®Œæˆä»¥ä¸‹å·¥ä½œï¼š  
1. å¤„ç†æºä»£ç ä¸­çš„ç©ºæ ¼  
2. ä¸¤ä¸ªå¤šä½æ•´æ•°(n>0) çš„è¿ç®—  
3. ä¸¤ä¸ªæ•°å­—çš„å‡æ³•è¿ç®—  

ä»¥ä¸‹å°±æ˜¯æ–°è®¡ç®—å™¨çš„æºä»£ç ï¼š  

```python
# -*- coding: UTF-8 -*- 
# ä¸æŒ‡å®šå­—ç¬¦é›†çš„è¯ï¼Œå¯èƒ½ä¸è¯†åˆ«ä¸­æ–‡æ³¨é‡Š

# è¿ç®—ç¬¦ç±»å‹å¢åŠ å‡æ³•
INTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'

class Token(object):
    def __init__(self, type, value):
        # token type: INTEGER, PLUS, or EOF
        self.type = type
        # token value: 0, 1, 2. 3, 4, 5, 6, 7, 8, 9, '+', or None
        self.value = value

    def __str__(self):
        """åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œæœ‰åˆ©äºè°ƒè¯•:
            Token(INTEGER, 3)
            Token(PLUS, '+')
        """
        return 'Token({type}, {value})'.format(
            type=self.type,
            # å°†å¯¹è±¡è½¬åŒ–ä¸ºè§£é‡Šå™¨è¯»å–çš„å½¢å¼ï¼Œå­—ç¬¦ä¸²
            # str()è°ƒç”¨__str__()
            # repr()è°ƒç”¨__repr__()
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()

# è§£é‡Šå™¨ç±»
class Interpreter(object):
    def __init__(self, text):
        # å®¢æˆ·ç«¯è¾“å…¥ï¼Œå¦‚ "3 + 5", "12 - 5" ç­‰ç­‰
        self.text = text
        # å½“å‰å­—ç¬¦ä½ç½®
        self.pos = 0
        # å½“å‰çš„Token
        self.current_token = None
        # å½“å‰å­—ç¬¦
        self.current_char = self.text[self.pos]

    def error(self):
        raise Exception('Error parsing input')

    def advance(self):
        """è·å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶èµ‹å€¼ç»™å˜é‡current_char"""
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # æºä»£ç ç»“æŸ
        else:
            self.current_char = self.text[self.pos]

	# è·³è¿‡ç©ºæ ¼
    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

	# æ•´æ•°
    def integer(self):
        """è·å–å¤šä¸ªå­—ç¬¦å¹¶ç»„æˆä¸ºä¸€ä¸ªæ•´æ•°"""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def get_next_token(self):
        """è¯æ³•åˆ†æå™¨
        	æ ¹æ®å˜é‡current_char æ¥åˆ¤æ–­
        """
        while self.current_char is not None:

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char == '+':
                self.advance()
                return Token(PLUS, '+')

            if self.current_char == '-':
                self.advance()
                return Token(MINUS, '-')

            self.error()

        return Token(EOF, None)

    def eat(self, token_type):
        # åŒ¹é…Token ç±»å‹
        if self.current_token.type == token_type:
            self.current_token = self.get_next_token()
        else:
            self.error()

    def expr(self):
        """è§£é‡Šå™¨ æˆ–è€…å« è¯­æ³•åˆ†æå™¨

        expr -> INTEGER PLUS INTEGER
        expr -> INTEGER MINUS INTEGER
        """
        self.current_token = self.get_next_token()

        # å·¦å€¼ä¸ºæ•´æ•°
        left = self.current_token
        self.eat(INTEGER)

        # æ“ä½œç¬¦
        op = self.current_token
        if op.type == PLUS:
            self.eat(PLUS)
        else:
            self.eat(MINUS)

        # å³å€¼ä¸ºæ•´æ•°
        right = self.current_token
        self.eat(INTEGER)
        
        # æ ¹æ®è¿ç®—ç¬¦è®¡ç®—æœ€ç»ˆç»“æœ
        if op.type == PLUS:
            result = left.value + right.value
        else:
            result = left.value - right.value
        return result


def main():
    while True:
        try:
            # To run under Python3 replace 'raw_input' call
            # with 'input'
            text = raw_input('calc> ')
        except EOFError:
            break
        if not text:
            continue
        interpreter = Interpreter(text)
        result = interpreter.expr()
        print(result)


if __name__ == '__main__':
    main()
```

å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸º`calc2.py` æˆ–è€…ç›´æ¥ä»[Github](https://github.com/rspivak/lsbasi/blob/master/part2/calc2.py)ä¸‹è½½å¹¶è¿è¡Œã€‚çœ‹è¾“å‡ºæ˜¯å¦ç´ å’Œé¢„æœŸï¼šå¯ä»¥å¤„ç†ç©ºæ ¼ï¼›å¤šä½æ“ä½œæ•°ï¼›å‡æ³•è¿ç®—ã€‚  

ä¸‹é¢æ˜¯åœ¨æˆ‘ç”µè„‘ä¸Šè¿è¡Œçš„ç»“æœï¼š  
```python
$ python calc2.py
calc> 27 + 3
30
calc> 27 - 7
20
calc>
```  

ä¸[01_åˆè¯†è§£é‡Šå™¨_æ„é€ ç®€å•çš„åŠ æ³•å™¨](../lsbasi_cn/01_%E5%88%9D%E8%AF%86%E8%A7%A3%E9%87%8A%E5%99%A8_%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8.md)ç›¸æ¯”ï¼Œä»£ç çš„ä¸»è¦æ”¹åŠ¨ä¸ºï¼š  
1. `get_next_token()` æ–¹æ³•é‡æ„ã€‚å°†`pos` è‡ªå¢åŠŸèƒ½ç‹¬ç«‹åˆ°`advace()` æ–¹æ³•ï¼›  
2. æ–°å¢ä¸¤ä¸ªæ–¹æ³•ï¼š`skip_whitespace()` å¿½ç•¥ç©ºæ ¼å’Œ`integer()` è·å–å¤šä½æ•´æ•°ï¼›  
3. `expr()` æ–¹æ³•å¯ä»¥è¯†åˆ«`int + int` å’Œ`int - int` çš„Token åºåˆ—ã€‚  

åœ¨[01_åˆè¯†è§£é‡Šå™¨_æ„é€ ç®€å•çš„åŠ æ³•å™¨](../lsbasi_cn/01_%E5%88%9D%E8%AF%86%E8%A7%A3%E9%87%8A%E5%99%A8_%E6%9E%84%E9%80%A0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8.md)æˆ‘ä»¬å­¦ä¹ äº†è¯æ³•åˆ†æä¸è¯æ³•åˆ†æå™¨(lexical analyzer)ä¸¤ä¸ªé‡è¦æ¦‚å¿µã€‚ä»Šå¤©æˆ‘ä»¬å†æ¥ä»‹ç»è¯ç´ (lexemes)ã€è¯­æ³•åˆ†æä¸è¯­æ³•åˆ†æå™¨ã€‚  

æˆ‘ä»¬ä¹‹å‰å·²ç»æœ‰æ­¤çš„æ¦‚å¿µäº†ï¼Œä¸‹é¢æˆ‘ä»¬æ¥ä»‹ç»ä¸€ä¸‹è¯ç´ ã€‚ä»€ä¹ˆæ˜¯è¯ç´ ï¼Ÿ**è¯ç´ æ˜¯ä¸€ç³»åˆ—ç¬¦åˆæŸä¸ªè¯çš„ç‰¹å¾å­—ç¬¦**ã€‚ä¸‹é¢å›¾ç‰‡åŒ…å«ä¸€äº›ç®€å•çš„è¯ç´ ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬ç†è§£è¯ä¸è¯ç´ çš„å…³ç³»ï¼š  

> è¯‘æ³¨ï¼šä¸€ä¸ªè¯å¯ä»¥çœ‹ä½œå…·æœ‰æŸä¸ªç‰¹å¾çš„å‡ ä½•ï¼›è¯ç´ å°±æ˜¯è¿™ä¸ªå‡ ä½•ä¸­çš„å­é›†ã€‚å­é›†çš„ä¸ªæ•°å¯ä»¥æ˜¯æ— é™å¤šä¸ªã€‚

![lsbasi_part2_lexemes.png](../_resources/c20329c2479440fd8dec820a67d227ac.png)  

è¿˜è®°å¾—æˆ‘ä»¬çš„`expr()` æ–¹æ³•å—ï¼Ÿæˆ‘ä¹‹å‰è¯´å®ƒæ˜¯å®é™…è¿›è¡Œè¿ç®—çš„åœ°æ–¹ã€‚ä½†æ˜¯åœ¨æˆ‘ä»¬è§£é‡Šä¸€ä¸ªè¡¨è¾¾å¼ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å®ƒæ˜¯ä»€ä¹ˆæ ·çš„çŸ­è¯­`phrase`ï¼Œä¾‹å¦‚ï¼šåŠ æ³•æˆ–è€…å‡æ³•ã€‚`expr()` ä¸»è¦å®Œæˆï¼šä»`get_next_token()` ç”Ÿæˆçš„Token åºåˆ—ä¸­è¯†åˆ«å‡ºç‰¹å®šçš„è¯­æ³•ç»“æ„ï¼Œå¹¶è®¡ç®—æœ€ç»ˆç»“æœã€‚  

é€šè¿‡Token åºåˆ—ç¡®å®šç»“æ„çš„è¿‡ç¨‹ç§°ä¸ºè§£æã€‚å®ç°è§£æåŠŸèƒ½çš„éƒ¨åˆ†ç§°ä¸ºè§£æå™¨ã€‚  

`expr()` æ–¹æ³•å°±æ˜¯æ‰§è¡Œè§£æçš„åœ°æ–¹ï¼Œé€šè¿‡è§£æToken ç»“æ„ï¼Œè®¡ç®—ç»“æœå¹¶è¿”å›ã€‚  

ä¸‹é¢ï¼Œæ˜¯ä»Šå¤©çš„è”ç³»ï¼š  

![lsbasi_part2_exercises.png](../_resources/0de4bca4fedd43099f33924bf1e204e9.png)

1. æ‰©å±•è®¡ç®—å™¨ï¼Œä½¿ä¹‹å¯ä»¥æ”¯æŒä¹˜æ³•ï¼›  
2. æ‰©å±•è®¡ç®—å™¨ï¼Œä½¿ä¹‹å¯ä»¥æ”¯æŒé™¤æ³•ï¼›  
3. ä¿®æ”¹ä»£ç ï¼Œä½¿ä¹‹æ”¯æŒè¿ç»­çš„è¿ç®—ã€‚  

**è‡ªæ£€**  
1. ä»€ä¹ˆæ˜¯è¯ç´ ï¼Ÿ  
2. ä»Token åºåˆ—ä¸­è¯†åˆ«ç‰¹å®šè¯­æ³•æœºæ„çš„è¿‡ç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ  
3. æ‰§è¡Œè¿™éƒ¨åˆ†åŠŸèƒ½çš„ç»„ä»¶å«ä»€ä¹ˆï¼Ÿ  

å¸Œæœ›ä½ å–œæ¬¢ã€‚ä¸‹ç¯‡æ–‡ç« å°†ä¼šå¸¦ä½ æ‰©å±•è¿™ä¸ªè®¡ç®—å™¨ï¼Œä½¿ä¹‹å¯ä»¥å¤„ç†æ›´å¤æ‚çš„ç®—æ•°è¿ç®—ï¼Œæ•¬è¯·æœŸå¾…ã€‚  
ä»¥ä¸‹ä¹¦ç±å¯èƒ½ä¼šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š  

1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)  
2. [Writing Compilers and Interpreters: A Software Engineering Approach](http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=UCLGQTPIYSWYKRRM)  
3. [Modern Compiler Implementation in Java](http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=052182060X&linkCode=as2&tag=russblo0b-20&linkId=ZSKKZMV7YWR22NMW)  
4. [Modern Compiler Design](http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1461446988&linkCode=as2&tag=russblo0b-20&linkId=PAXWJP5WCPZ7RKRD)  
5. [Compilers: Principles, Techniques, and Tools (2nd Edition)](http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321486811&linkCode=as2&tag=russblo0b-20&linkId=GOEGDQG4HIHU56FQ)   

-----  
2020-06-11 13:50  

è¯‘æ³¨ï¼šå¥æ³•(syntax)ï¼Œæœ‰äº›åœ°æ–¹ä¼šè¢«ç¿»è¯‘æˆè¯­æ³•(grammar)ã€‚äºŒè€…ä¹‹é—´æ˜¯æœ‰åŒºåˆ«çš„ï¼Œgrammar é™¤äº†ç‰¹å®šçš„å¥å­æˆåˆ†å¤–ï¼Œè¿˜åŒ…å«æ—¶æ€ç­‰ä¿¡æ¯ï¼Œä¸€èˆ¬å¸¸ç”¨äºè‡ªç„¶è¯­è¨€ï¼›è€Œsyntax å¸¸ç”¨äºæœºå™¨è¯­è¨€ã€‚



