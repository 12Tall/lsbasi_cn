18_æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨  

ğŸ“… 2020-02-20  

> â€œå°½å·±æ‰€èƒ½åšå¾—æœ€å¥½ã€‚ ç„¶åï¼Œå½“ä½ æ‡‚å¾—æ›´å¥½çš„æ–¹æ³•æ—¶ï¼Œå†åšå¾—æ›´å¥½ã€‚â€ â€”â€” é©¬å¨…Â·å®‰æ°å¢  

ä»Šå¤©æˆ‘ä»¬å°†è¿æ¥ä¸€ä¸ªå·¨å¤§çš„é‡Œç¨‹ç¢‘ï¼šæ‰§è¡Œè¿‡ç¨‹è°ƒç”¨ã€‚å¦‚æœè¿™éƒ½ä¸è®©äººå¿ƒåŠ¨ï¼Œæˆ‘å°±ä¸çŸ¥é“è¿™ä¸–ç•Œä¸Šè¿˜æœ‰ä»€ä¹ˆä¼šè®©äººå¿ƒåŠ¨äº†ã€‚  
![](../_resources/lsbasi_part18_milestones.png)  

å‡†å¤‡å¥½ç»§ç»­å‰è¿›äº†å—ï¼Ÿæœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†ä»¥ä¸‹é¢ä»£ç ä¸ºä¾‹ï¼š  
```pascal
program Main;

procedure Alpha(a : integer; b : integer);
var x : integer;
begin
   x := (a + b ) * 2;
end;

begin { Main }

   Alpha(3 + 5, 7);  { procedure call }

end.  { Main }
```  

ä¸Šé¢ä»£ç åŒ…å«ä¸€å¤„å‡½æ•°å£°æ˜å’Œä¸€å¤„å‡½æ•°è°ƒç”¨ã€‚ä»Šå¤©æˆ‘ä»¬åªå…³æ³¨è¿‡ç¨‹è°ƒç”¨ä¸­çš„å‚æ•°å’Œå±€éƒ¨å˜é‡ã€‚åé¢ä¸¤ç« æˆ‘ä»¬å°†è®¨è®ºåµŒå¥—çš„è¿‡ç¨‹è°ƒç”¨å’Œéå±€éƒ¨å˜é‡ã€‚  

è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä¸ºäº†è°ƒç”¨`Alpha(3+5, 7)` æ‰€éœ€è¦çš„ç®—æ³•ã€‚ä¸€æ­¥ä¸€æ­¥æ¥ï¼š  
1. åˆ›å»ºä¸€ä¸ªæ ˆå¸§  
2. ä¿å­˜å®å‚åˆ°æ ˆå¸§  
3. å°†æ ˆå¸§å‹å…¥è°ƒç”¨æ ˆ  
4. æ‰§è¡Œè¿‡ç¨‹ä½“  
5. å¼¹å‡ºæ ˆå¸§  

åœ¨è§£é‡Šå™¨ä¸­ï¼Œè¿‡ç¨‹çš„è°ƒç”¨ç”±`visit_Procedure` æ–¹æ³•è¿›è¡Œå¤„ç†ã€‚ç›®å‰è¯¥æ–¹æ³•è¿˜æ˜¯ç©ºçš„ï¼š  
```python  
class Interpreter(NodeVisitor):
    ...

    def visit_ProcedureCall(self, node):
        pass
```  

æˆ‘ä»¬é€šè¿‡ä¸Šé¢çš„æ­¥éª¤ï¼Œä¸€ç‚¹ç‚¹å®Œå–„ä»£ç ï¼Œç›´åˆ°å¯ä»¥æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨ã€‚  

## åˆ›å»ºæ ˆå¸§  
æˆ‘ä»¬ä¸Šä¸€ç« æåˆ°è¿‡ï¼Œæ ˆå¸§æ˜¯ä¸€ä¸ªç±»ä¼¼äºå­—å…¸çš„å¯¹è±¡ï¼Œè´Ÿè´£ç»´æŠ¤å½“å‰è°ƒç”¨çš„è¿‡ç¨‹æˆ–å‡½æ•°ï¼ŒæŠ‘æˆ–ç¨‹åºæ‰€éœ€çš„ä¿¡æ¯ã€‚ä»¥è¿‡ç¨‹è°ƒç”¨ä¸ºä¾‹ï¼Œæ ˆå¸§åŒ…å«äº†å½¢å‚å’Œå±€éƒ¨å˜é‡çš„å€¼ã€‚æ‰€ä»¥ä¸ºäº†å­˜å‚¨è¿‡ç¨‹çš„å‚æ•°å’Œå±€éƒ¨å˜é‡ç­‰ä¿¡æ¯ï¼Œæˆ‘ä»¬éœ€è¦é¦–å…ˆåˆ›å»ºæ ˆå¸§ã€‚å›é¡¾æ ˆå¸§çš„æ„é€ å‡½æ•°ï¼Œå®ƒéœ€è¦ä¸‰ä¸ªå‚æ•°ï¼š  
- `name`ï¼šè¿‡ç¨‹åï¼Œä¹Ÿæ˜¯æ ˆå¸§çš„åå­—  
- `type`ï¼šæ ˆå¸§çš„ç±»å‹ï¼Œ`PROGRAM`ï¼Œæˆ–`PROCEDURE`  
- `nesting_level`ï¼šåµŒå¥—æ·±åº¦ï¼Œè¿‡ç¨‹çš„åµŒå¥—æ·±åº¦ä¸º2ï¼Œå› ä¸ºç¨‹åºçš„æ ˆå¸§æ·±åº¦æ˜¯1  

åœ¨æˆ‘ä»¬æ‰©å±•`visit_ProcedureCall` æ–¹æ³•å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå¢è®¾`PROCEDURE` æ ˆå¸§ç±»å‹ï¼š  
```python  
class ARType(Enum):
    PROGRAM   = 'PROGRAM'
    PROCEDURE = 'PROCEDURE'
```

ä¸‹é¢ï¼Œæˆ‘ä»¬åœ¨è¿›å…¥`visit_ProcedureCall` æ—¶åˆ›å»ºæ ˆå¸§ï¼š  
```python
def visit_ProcedureCall(self, node):
    proc_name = node.proc_name

    ar = ActivationRecord(
        name=proc_name,
        type=ARType.PROCEDURE,
        nesting_level=2,
    )
```  

åªè¦æˆ‘ä»¬çŸ¥é“äº†æ„é€ å‡½æ•°çš„å‚æ•°çš„æ„ä¹‰ï¼Œåˆ›å»ºæ ˆå¸§çš„ä»£ç å¾ˆç®€å•ã€‚  

## ä¿å­˜å‚æ•°  
> æ³¨ï¼š  
> å½¢å‚æ˜¯åœ¨è¿‡ç¨‹å®šä¹‰æ—¶ã€ä»¥åŠè¿‡ç¨‹ä½“å†…éƒ¨ä¼šç”¨åˆ°çš„å‚æ•°  
> å®å‚æ˜¯åœ¨è°ƒç”¨è¿‡ç¨‹æ—¶ï¼Œéœ€è¦ä¼ å…¥çš„å‚æ•°ã€æˆ–è¡¨è¾¾å¼  

ä¸ºäº†åœ¨æ ˆå¸§ä¸­ä¿å­˜æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦ä»¥ä¸‹æ­¥éª¤ï¼š  
- è·å–è¿‡ç¨‹çš„å½¢å‚åˆ—è¡¨  
- è·å–è¿‡ç¨‹çš„å®å‚åˆ—è¡¨  
- å¯¹äºæ¯ä¸€ä¸ªå½¢å‚ï¼Œæ‰¾å‡ºå¯¹åº”çš„å®å‚ï¼Œåœ¨è®¡ç®—å‡ºç»“æœä¹‹åï¼Œå°†æ•°å€¼å­˜å‚¨åˆ°æ ˆå¸§å“åº”çš„ä½ç½®  

ä»¥ä¸‹é¢æ ˆå¸§çš„å®šä¹‰å’Œè°ƒç”¨ä¸ºä¾‹ï¼š  
```pascal
procedure Alpha(a : integer; b : integer);

Alpha(3 + 5, 7);
```  

åœ¨æ‰§è¡Œå®Œä¸Šè¿°ä»£ç åï¼ˆç¦»å¼€Alpha è¿‡ç¨‹ä¹‹å‰ï¼‰ï¼Œæ ˆå¸§çš„å†…å®¹åº”è¯¥å¦‚ä¸‹æ‰€ç¤ºï¼š  
```  
2: PROCEDURE Alpha
   a                   : 8
   b                   : 7
```

ä¸‹é¢æ˜¯å®ç°ä¸Šè¿°æ­¥éª¤çš„ä»£ç ï¼š  
```python  
proc_symbol = node.proc_symbol

formal_params = proc_symbol.formal_params
actual_params = node.actual_params

for param_symbol, argument_node in zip(formal_params, actual_params):
    ar[param_symbol.name] = self.visit(argument_node)
```
æˆ‘ä»¬éœ€è¦ä»”ç»†ç ”ç©¶ä¸€ä¸‹ä¸Šé¢çš„ä»£ç ï¼  

### è·å–å½¢å‚åˆ—è¡¨  
æˆ‘ä»¬åœ¨æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨æ—¶éœ€è¦ç”¨åˆ°å½¢å‚åˆ—è¡¨ï¼Œä½†æ˜¯åº”è¯¥ä»å“ªé‡Œè·å¾—å‘¢ï¼ŸAST èŠ‚ç‚¹ä¸­åªæœ‰è¿‡ç¨‹å®šä¹‰æ—¶æ‰æœ‰å½¢å‚ã€‚è€Œæˆ‘ä»¬åœ¨è¯­ä¹‰åˆ†æï¼Œåˆ›å»º`ProcedureSymbol` è¿‡ç¨‹ç¬¦å·è¡¨æ—¶ï¼Œåˆ™èƒ½æ”¶é›†åˆ°å½¢å‚åˆ—è¡¨çš„ä¿¡æ¯ï¼š  
```python
class Symbol:
    def __init__(self, name, type=None):
        self.name = name
        self.type = type


class ProcedureSymbol(Symbol):
    def __init__(self, name, formal_params=None):
        super().__init__(name)
        # a list of VarSymbol objects
        self.formal_params = [] if formal_params is None else formal_params
```

è¯­ä¹‰åˆ†ææ—¶ï¼ŒåµŒå¥—ä½œç”¨åŸŸç¬¦å·è¡¨çš„å†…å®¹å¦‚ä¸‹ï¼š  
```
SCOPE (SCOPED SYMBOL TABLE)
===========================
Scope name     : global
Scope level    : 1
Enclosing scope: None
Scope (Scoped symbol table) contents
------------------------------------
INTEGER: <BuiltinTypeSymbol(name='INTEGER')>
   REAL: <BuiltinTypeSymbol(name='REAL')>
  Alpha: <ProcedureSymbol(name=Alpha, parameters=[<VarSymbol(name='a', type='INTEGER')>, <VarSymbol(name='b', type='INTEGER')>])>
```  

æ—¢ç„¶çŸ¥é“äº†å½¢å‚åˆ—è¡¨åº”è¯¥ä»è¯­ä¹‰åˆ†ææ—¶è·å–ï¼Œé‚£æˆ‘ä»¬åº”è¯¥æ€ä¹ˆä»æŠ½è±¡è¯­æ³•æ ‘ä¸Šå¾—åˆ°å‘¢ï¼Ÿå› ä¸ºè§£é‡Šå™¨åªæ¥è§¦ASTã€‚å…ˆçœ‹ä¸€ä¸‹æˆ‘ä»¬ç°æœ‰çš„ä»£ç ï¼š  
```python
def visit_ProcedureCall(self, node):
    proc_name = node.proc_name

    ar = ActivationRecord(
        name=proc_name,
        type=ARType.PROCEDURE,
        nesting_level=2,
    )
```
åœ¨æœ€å¼€å§‹çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡`proc_symbol = node.proc_symbol` è·å–è¿‡ç¨‹çš„ç¬¦å·è¡¨ï¼Œä½†æ˜¯æˆ‘ä»¬åœ¨`ProcedureCall` ç±»å‹ä¸­è¿˜æ²¡æœ‰`proc_symbol` çš„å±æ€§ï¼š  
```python
class ProcedureCall(AST):
    def __init__(self, proc_name, actual_params, token):
        self.proc_name = proc_name
        self.actual_params = actual_params  # a list of AST nodes
        self.token = token
```  

æ‰€ä»¥æˆ‘ä»¬é¦–å…ˆåœ¨æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹`ProcedureCall` ä¸­æ·»åŠ `proc_symbol` å±æ€§ï¼š  
```python
class ProcedureCall(AST):
    def __init__(self, proc_name, actual_params, token):
        self.proc_name = proc_name
        self.actual_params = actual_params  # a list of AST nodes
        self.token = token
        # a reference to procedure declaration symbol
        self.proc_symbol = None
```  

åˆ°è¿™é‡Œè¿˜å¾ˆå®¹æ˜“ç†è§£ã€‚ä½†æ€ä¹ˆèƒ½è®©`proc_symbol` å±æ€§æŒ‡å‘æ­£ç¡®çš„ç¬¦å·è¡¨å‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦åœ¨è¯­ä¹‰åˆ†æä¸­ï¼Œéå†`ProcedureCall` æ—¶ï¼Œå°†äº§ç”Ÿçš„ç¬¦å·è¡¨æŒ‚è½½åˆ°è¯¥èŠ‚ç‚¹ä¸‹é¢ã€‚ä¸‹é¢æ˜¯æˆ‘ä»¬ä»¥å‰çš„ä»£ç ï¼š  
```python
class SemanticAnalyzer(NodeVisitor):
    ...

    def visit_ProcedureCall(self, node):
        for param_node in node.actual_params:
            self.visit(param_node)
```

å› ä¸ºæˆ‘ä»¬åœ¨è¯­ä¹‰åˆ†æéå†AST æ—¶ï¼Œå¯ä»¥è®¿é—®å½“å‰ä½œç”¨åŸŸï¼Œäºæ˜¯å°±å¯ä»¥é€šè¿‡è¿‡ç¨‹åæŸ¥æ‰¾è¿‡ç¨‹ç¬¦å·è¡¨å¹¶æŒ‚è½½åˆ°å½“å‰`ProcedureCall` èŠ‚ç‚¹ä¸‹é¢ï¼š  
```python
class SemanticAnalyzer(NodeVisitor):
    ...

    def visit_ProcedureCall(self, node):
        for param_node in node.actual_params:
            self.visit(param_node)

        proc_symbol = self.current_scope.lookup(node.proc_name)
        # accessed by the interpreter when executing procedure call
        node.proc_symbol = proc_symbol
```

åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ç¬¦å·åè§£æåˆ°äº†å¯¹åº”çš„ä½œç”¨åŸŸç¬¦å·è¡¨ï¼Œå¹¶å°†å…¶æŒ‚è½½åˆ°æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹ä¸‹é¢ã€‚å¯¹äºæˆ‘ä»¬çš„ç¤ºä¾‹ä»£ç è€Œè¨€ï¼Œè¯­ä¹‰åˆ†æä¹‹åï¼Œæˆ‘ä»¬çš„æŠ½è±¡è¯­æ³•æ ‘ä¸å…¨å±€ä½œç”¨åŸŸç¬¦å·è¡¨çš„å…³ç³»å¦‚ä¸‹ï¼š  
![](../_resources/lsbasi_part18_astsymbollink.png)  

ä»ä¸Šé¢çš„å›¾ç‰‡å¯ä»¥çœ‹å‡ºï¼Œæœ‰äº†è¿™äº›æ“ä½œï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨`visit_ProcedureCall` æ–¹æ³•ä¸­è®¿é—®ä½œç”¨åŸŸç¬¦å·è¡¨ï¼Œä»è€Œè·å–å½¢å‚`formal_params` å­—æ®µäº†ï¼š  
```python
proc_symbol = node.proc_symbol

proc_symbol.formal_params  # aka parameters
```  

### è·å–å®å‚åˆ—è¡¨  
å®å‚åˆ—è¡¨å·²ç»åœ¨`ProcedureCall` èŠ‚ç‚¹ä¸­å­˜åœ¨äº†ï¼Œæ‰€ä»¥å®¹æ˜“è·å–ï¼š  
```python
node.actual_params  # aka arguments
```  

### ç»™å½¢å‚èµ‹å€¼  
æœ‰äº†å½¢å‚åˆ—è¡¨å’Œå®å‚åˆ—è¡¨ï¼Œæˆ‘ä»¬åªéœ€è¦æŒ‰é¡ºåºå°†å®å‚è®¡ç®—å‡ºæ¥çš„å€¼èµ‹ç»™æ ˆå¸§ä¸­çš„å½¢å‚å°±å¥½äº†ã€‚å¯ä»¥é€šè¿‡Python çš„[zip()](https://docs.python.org/3/library/functions.html#zip) å‡½æ•°æ¥ä»ä¸¤ä¸ªæ•°ç»„ç”Ÿæˆé”®å€¼å¯¹ï¼š  
```python
proc_symbol = node.proc_symbol

formal_params = proc_symbol.formal_params
actual_params = node.actual_params

for param_symbol, argument_node in zip(formal_params, actual_params):
    ar[param_symbol.name] = self.visit(argument_node)
```  

ä¸€æ—¦ç†è§£äº†`zip()` æ–¹æ³•æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œé‚£ä¹ˆä»£ç ä¸­çš„`for` å¾ªç¯å°±å®¹æ˜“ç†è§£äº†ã€‚ä¸‹é¢çš„ä¾‹å­ä¹Ÿè®¸èƒ½å¸®åŠ©ä½ ç†è§£ï¼š  
```python
>>> formal_params = ['a', 'b', 'c']
>>> actual_params = [1, 2, 3]
>>>
>>> zipped = zip(formal_params, actual_params)
>>>
>>> list(zipped)
[('a', 1), ('b', 2), ('c', 3)]
```

ç»™å½¢å‚èµ‹å€¼å°±æ›´ç®€å•äº†ï¼š  
```python
ar[param_symbol.name] = self.visit(argument_node)
```

æ ˆå¸§ä¸­ä»¥å½¢å‚çš„`name` ä¸º`key`ï¼Œç„¶åä»¥å®å‚è®¡ç®—åçš„å€¼ä¸º`value`ï¼Œä½œä¸ºæœ€ç»ˆçš„å‚æ•°ä¼ é€’ç»™è¿‡ç¨‹çš„è°ƒç”¨ã€‚ç›®å‰æˆ‘ä»¬å·²ç»å®Œæˆäº†è¿™ä¹ˆå¤šï¼š  
```python
class Interpreter(NodeVisitor):
    ...

    def visit_ProcedureCall(self, node):
        proc_name = node.proc_name

        ar = ActivationRecord(
            name=proc_name,
            type=ARType.PROCEDURE,
            nesting_level=2,
        )

        proc_symbol = node.proc_symbol

        formal_params = proc_symbol.formal_params
        actual_params = node.actual_params

        for param_symbol, argument_node in zip(formal_params, actual_params):
            ar[param_symbol.name] = self.visit(argument_node)
```  

## å°†æ ˆå¸§å‹å…¥è°ƒç”¨æ ˆ  
åœ¨æˆ‘ä»¬æˆåŠŸåˆ›å»ºæ ˆå¸§åï¼Œéœ€è¦å°†æ ˆå¸§å‹å…¥è°ƒç”¨æ ˆï¼Œå…¶å®å¾ˆç®€å•ï¼š  
```python
self.call_stack.push(ar)
```

éœ€è¦è®°ä½çš„æ˜¯ï¼šå½“å‰æ‰§è¡Œçš„è¿‡ç¨‹çš„æ ˆå¸§æ€»æ˜¯åœ¨è°ƒç”¨æ ˆçš„æ ˆé¡¶ã€‚è¿™æ ·è®¾è®¡çš„åŸå› æ˜¯ä¸ºäº†ä»è¿‡ç¨‹è°ƒç”¨ä¸­æ›´å®¹æ˜“è®¿é—®åˆ°å‚æ•°å’Œå±€éƒ¨å˜é‡ã€‚ä¸‹é¢æ˜¯æ›´æ–°åçš„`visit_ProcedureCall` æ–¹æ³•ï¼š  
```python
def visit_ProcedureCall(self, node):
    proc_name = node.proc_name

    ar = ActivationRecord(
        name=proc_name,
        type=ARType.PROCEDURE,
        nesting_level=2,
    )

    proc_symbol = node.proc_symbol

    formal_params = proc_symbol.formal_params
    actual_params = node.actual_params

    for param_symbol, argument_node in zip(formal_params, actual_params):
        ar[param_symbol.name] = self.visit(argument_node)

    self.call_stack.push(ar)
```  

## æ‰§è¡Œè¿‡ç¨‹ä½“  
ä¸‡äº‹ä¿±å¤‡ï¼Œç°åœ¨å¯ä»¥æ‰§è¡Œè¿‡ç¨‹ä½“äº†ã€‚  
ç­‰ç­‰ï¼Œæˆ‘ä»¬åº”è¯¥ä»å“ªé‡Œè·å–è¿‡ç¨‹ä½“å‘¢ï¼Ÿæˆ‘ä»¬åœ¨éå†`ProcedureCall` çš„æ—¶å€™åªèƒ½ç›´æ¥çœ‹åˆ°å®å‚ï¼Œæ‰€ä»¥è¿‡ç¨‹ä½“è¿˜æ˜¯å¾—ä»è¿‡ç¨‹å®šä¹‰æ—¶çš„æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹ä¸­è·å–ã€‚  

åœ¨æ‰§è¡Œè¿‡ç¨‹è°ƒç”¨æ—¶è¯¥å¦‚ä½•è®¿é—®è¿‡ç¨‹ä½“å‘¢ï¼Ÿæ¢å¥è¯è¯´ï¼Œåœ¨éå†`ProcedureCall` æ—¶éœ€è¦ä»å¯¹åº”çš„è¿‡ç¨‹å£°æ˜`ProcedureDecl` ä¸­è·å–åˆ°`bloc_node` èŠ‚ç‚¹ã€‚è¯¥èŠ‚ç‚¹æŒ‡å‘è¿‡ç¨‹ä½“çš„å­æŠ½è±¡è¯­æ³•æ ‘ã€‚æƒ³æƒ³è¯¥æ€ä¹ˆå®ç°å‘¢ï¼Ÿ  

æˆ‘ä»¬å·²ç»è®¿é—®è¿‡è¿‡ç¨‹ç¬¦å·è¡¨äº†ï¼Œå…¶ä¸­åŒ…å«äº†è¿‡ç¨‹å£°æ˜çš„ä¿¡æ¯ã€‚æˆ‘ä»¬æˆ–è®¸ä¹Ÿå¯ä»¥ä»ç¬¦å·è¡¨ä¸­è·å–å…¶è¿‡ç¨‹æç›¸å…³çš„ä¿¡æ¯ã€‚äºæ˜¯æˆ‘ä»¬æœ‰éœ€è¦æ”¹åŠ¨è¯­ä¹‰åˆ†æå™¨ï¼Œåœ¨`visit_ProcedureDecl` æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬èƒ½è·å–åˆ°è¿‡ç¨‹ç¬¦å·å’Œè¿‡ç¨‹ä½“`block_node`ã€‚æˆ‘ä»¬å¯ä»¥å°†`block_node` æŒ‚è½½ä¸ºè¿‡ç¨‹ç¬¦å·çš„`block_ast` å±æ€§ï¼š  
```python
class SemanticAnalyzer(NodeVisitor):

    def visit_ProcedureDecl(self, node):
        proc_name = node.proc_name
        proc_symbol = ProcedureSymbol(proc_name)
        ...
        self.log(f'LEAVE scope: {proc_name}')

        # accessed by the interpreter when executing procedure call
        proc_symbol.block_ast = node.block_node
```

æ›´æ˜ç¡®ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥æ‰©å±•`ProcedureSymbol` ç±»çš„æ„é€ å‡½æ•°ï¼š  
```python
class ProcedureSymbol(Symbol):
    def __init__(self, name, formal_params=None):
        ...
        # a reference to procedure's body (AST sub-tree)
        self.block_ast = None
```  

ä¸‹å›¾ä¸­ï¼Œå¯ä»¥çœ‹å‡ºè¿‡ç¨‹ç¬¦å·ä¸æŠ½è±¡è¯­æ³•æ ‘ä¹‹é—´çš„å…³ç³»ï¼š  
![](../_resources/lsbasi_part18_symbolastlink.png)  

äºæ˜¯ï¼Œæˆ‘ä»¬åœ¨`visit_ProcedureCall` æ–¹æ³•ä¸­è®¿é—®è¿‡ç¨‹ä½“å°±åƒåœ¨è®¿é—®è¿‡ç¨‹å£°æ˜æ—¶ä¸€æ ·ç®€å•äº†ï¼š  
```python  
self.visit(proc_symbol.block_ast)
```  

ä»¥ä¸‹æ˜¯`visit_ProcedureCall` æ–¹æ³•çš„å®Œæ•´ä»£ç ï¼š  
```python
def visit_ProcedureCall(self, node):
    proc_name = node.proc_name

    ar = ActivationRecord(
        name=proc_name,
        type=ARType.PROCEDURE,
        nesting_level=2,
    )

    proc_symbol = node.proc_symbol

    formal_params = proc_symbol.formal_params
    actual_params = node.actual_params

    for param_symbol, argument_node in zip(formal_params, actual_params):
        ar[param_symbol.name] = self.visit(argument_node)

    self.call_stack.push(ar)

    # evaluate procedure body
    self.visit(proc_symbol.block_ast)
```

ä¸çŸ¥ä½ æ˜¯å¦å¯¹æˆ‘ä»¬ä¸Šä¸€ç« åœ¨æ ˆå¸§ä¸­ä¸­å­˜å–å˜é‡çš„æ–¹æ³•è¿˜æœ‰æ²¡æœ‰å°è±¡ï¼š  
```python
def visit_Assign(self, node):
    var_name = node.left.value
    var_value = self.visit(node.right)

    ar = self.call_stack.peek()
    ar[var_name] = var_value

def visit_Var(self, node):
    var_name = node.value

    ar = self.call_stack.peek()
    var_value = ar.get(var_name)

    return var_value
```  

è¿™ä¸¤ä¸ªæ–¹æ³•å¹¶æ²¡æœ‰å˜åŠ¨ã€‚å½“è§£é‡Šåˆ°è¿‡ç¨‹ä½“çš„æ—¶å€™ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•å°†ä»æ ˆé¡¶å¸§ä¸­å­˜å–æ•°æ®ã€‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°è¿™ä¸€åˆ‡æ˜¯å¦‚ä½•é…åˆå’Œè¿ä½œçš„ã€‚

## å¼¹å‡ºæ ˆå¸§  
åœ¨æˆ‘ä»¬æ‰§è¡Œå®Œè¿‡ç¨‹ä½“åï¼Œæ ˆå¸§ä¸­çš„æ•°æ®å°±ä¸ä¼šå†è¢«ç”¨åˆ°äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ç¦»å¼€`visit_ProcedureCall` ä¹‹å‰ï¼Œéœ€è¦æ¸…ç†è°ƒç”¨æ ˆã€‚å³å¼¹å‡ºä¸€å¼€å§‹è¢«å‹å…¥çš„æ ˆå¸§ï¼š  
```python
def visit_ProcedureCall(self, node):
    proc_name = node.proc_name

    ar = ActivationRecord(
        name=proc_name,
        type=ARType.PROCEDURE,
        nesting_level=2,
    )

    proc_symbol = node.proc_symbol

    formal_params = proc_symbol.formal_params
    actual_params = node.actual_params

    for param_symbol, argument_node in zip(formal_params, actual_params):
        ar[param_symbol.name] = self.visit(argument_node)

    self.call_stack.push(ar)

    self.log(f'ENTER: PROCEDURE {proc_name}')
    self.log(str(self.call_stack))

    # evaluate procedure body
    self.visit(proc_symbol.block_ast)

    self.log(f'LEAVE: PROCEDURE {proc_name}')
    self.log(str(self.call_stack))

    self.call_stack.pop()
```  

é€šè¿‡ä»[GitHub](https://github.com/rspivak/lsbasi/tree/master/part18) ä¸‹è½½ä¸‹é¢ä»£ç [part18.pas](https://github.com/rspivak/lsbasi/blob/master/part18/part18.pas)ï¼Œå¯ä»¥çœ‹åˆ°è¿‡ç¨‹è°ƒç”¨æ˜¯å¦‚ä½•æ‰§è¡Œçš„ï¼š  
```pascal  
program Main;

procedure Alpha(a : integer; b : integer);
var x : integer;
begin
   x := (a + b ) * 2;
end;

begin { Main }

   Alpha(3 + 5, 7);  { procedure call }

end.  { Main }
```  

åŒæ ·ï¼Œä¸‹è½½[spi.py](https://github.com/rspivak/lsbasi/blob/master/part18/spi.py) å¹¶åœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œï¼š  
```shell-session
$ python spi.py part18.pas --stack
ENTER: PROGRAM Main
CALL STACK
1: PROGRAM Main


ENTER: PROCEDURE Alpha
CALL STACK
2: PROCEDURE Alpha
   a                   : 8
   b                   : 7
1: PROGRAM Main


LEAVE: PROCEDURE Alpha
CALL STACK
2: PROCEDURE Alpha
   a                   : 8
   b                   : 7
   x                   : 30
1: PROGRAM Main


LEAVE: PROGRAM Main
CALL STACK
1: PROGRAM Main
```  

çœ‹èµ·æ¥ä¸€åˆ‡æ­£å¸¸ã€‚ä¸‹é¢ä»”ç»†åˆ†æä¸€ä¸‹è°ƒç”¨æµç¨‹ã€‚  
1. ç¬¬ä¸€å—æ‰“å°æ—¥å¿—  
```
ENTER: PROGRAM Main
CALL STACK
1: PROGRAM Main
```  
ç¨‹åºé¦–å…ˆä¼šéå†`Program` èŠ‚ç‚¹ã€‚è¿™æ—¶ä¼šåˆ›å»ºè°ƒç”¨æ ˆå’Œç¬¬ä¸€ä¸ªæ ˆå¸§ï¼ˆå­˜å‚¨å…¨å±€å˜é‡ï¼‰ï¼Œè¿™é‡Œå…¨å±€æ ˆå¸§ä¸ºç©ºï¼Œå› ä¸ºæ²¡æœ‰å…¨å±€å˜é‡ã€‚  
2. ç¬¬äºŒå—æ‰“å°æ—¥å¿—  
```
ENTER: PROCEDURE Alpha
CALL STACK
2: PROCEDURE Alpha
   a                   : 8
   b                   : 7
1: PROGRAM Main
```  
ç¨‹åºéå†åˆ°`Alpha(3+5,7);` çš„è¿‡ç¨‹è°ƒç”¨ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰æ‰§è¡Œåˆ°è¿‡ç¨‹ä½“ï¼Œæ‰€ä»¥åªåˆ›å»ºäº†`Alpha` æ ˆå¸§ä¸ä¸¤ä¸ªå‚æ•°ã€‚è€Œè¿‡ç¨‹ä½“ä¸­å£°æ˜çš„å±€éƒ¨å˜é‡å¹¶ä¸å­˜åœ¨äºå½“å‰æ ˆå¸§ã€‚  
3. ç¬¬ä¸‰å—æ‰“å°æ—¥å¿— 
```
LEAVE: PROCEDURE Alpha
CALL STACK
2: PROCEDURE Alpha
   a                   : 8
   b                   : 7
   x                   : 30
1: PROGRAM Main
```  
åœ¨æ‰§è¡Œå®Œè¿‡ç¨‹ä½“ä¹‹åï¼Œç¨‹åºå‡†å¤‡é€€å‡ºè¿‡ç¨‹è°ƒç”¨ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œæ ˆå¸§ä¸­å‘ç°äº†å±€éƒ¨å˜é‡`x`ï¼Œæœ€å`Alpha` æ ˆå¸§ä»è°ƒç”¨æ ˆä¸­å¼¹å‡ºã€‚  

ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬çš„ç¨‹åºé™¤äº†è¿‡ç¨‹å‚æ•°å¤–ï¼Œè¿˜èƒ½å¤Ÿå°†å±€éƒ¨å˜é‡`x` èµ‹äºˆæ­£ç¡®çš„è®¡ç®—ç»“æœã€‚è¿™é‡Œæˆ‘ä»¬çš„è°ƒç”¨æ ˆçœ‹èµ·æ¥æ˜¯ä¸‹é¢çš„æ ·å­ï¼š   
![](../_resources/lsbasi_part18_callstack.png)
4. æœ€åçš„æ‰“å°æ—¥å¿—  
```
LEAVE: PROGRAM Main
CALL STACK
1: PROGRAM Main
```
ç¨‹åºç¦»å¼€`Program` èŠ‚ç‚¹ï¼Œè¡¨ç¤ºç€ç¨‹åºçš„ç»“æŸï¼Œè¿™æ˜¯ä¿å­˜å…¨å±€å˜é‡çš„æ ˆå¸§ä¹Ÿä¼šè¢«å¼¹å‡ºã€‚  

äºæ˜¯æˆ‘ä»¬çš„ç¨‹åºæˆåŠŸæ‰§è¡Œäº†è¿‡ç¨‹è°ƒç”¨ã€‚å¦‚æœä½ çœ‹åˆ°äº†è¿™é‡Œï¼Œé‚£ä¹ˆæ­å–œå’¯ï¼  
![](../_resources/lsbasi_part18_congrats.png)  

è¿™å¯¹äºæˆ‘ä»¬æ¥è¯´æ˜¯ä¸€ä¸ªå·¨å¤§çš„é‡Œç¨‹ç¢‘ï¼Œæ„Ÿè°¢ä½ çš„è€å¿ƒç­‰å¾…ã€‚ä»¥ä¸Šå°±æ˜¯ä»Šå¤©çš„å…¨éƒ¨å†…å®¹ï¼Œä¸‹ä¸€ç« æˆ‘ä»¬å°†è®¨è®ºæ‰§è¡ŒåµŒå¥—çš„è¿‡ç¨‹è°ƒç”¨ã€‚æ•¬è¯·æœŸå¾…ï¼Œå†è§ï¼  

## å‚è€ƒèµ„æ–™  
æœ‰å…´è¶£çš„è¯å¯ä»¥é˜…è¯»ä»¥ä¸‹ä¹¦ç±ï¼Œæ–‡ä¸­æœ‰å¤šå¤„å¯¹å®ƒä»¬çš„å¼•ç”¨ä¸å‚è€ƒï¼š  
1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)  
2. [Writing Compilers and Interpreters: A Software Engineering Approach](https://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=542d1267e34a529e0f69027af20e27f3)  
3. [Programming Language Pragmatics, Fourth Edition](https://www.amazon.com/gp/product/0124104096/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0124104096&linkCode=as2&tag=russblo0b-20&linkId=8db1da254b12fe6da1379957dda717fc)   



-----  
2022-07-15 01:18