07_è¡¨è¾¾å¼åµŒå¥—

ğŸ“… 2015-12-05  

> ä»Šå¤©çš„å†…å®¹æ¯”è¾ƒå¤šï¼Œå¸Œæœ›èƒ½è€å¿ƒçœ‹ä¸‹æ¥  

å°±åƒæˆ‘ä¹‹å‰ä¿è¯çš„ï¼Œä»Šå¤©æˆ‘ä»¬å°†ä¼šè®²ä¸€ä¸ªè´¯ç©¿æ•´ä¸ªæ–‡ç« ç³»åˆ—çš„æ•°æ®ç»“æ„ï¼ˆå…¶å®å°±æ˜¯æŠ½è±¡è¯­æ³•æ ‘ï¼‰ã€‚ç°åœ¨è®©æˆ‘ä»¬ç³»å¥½å®‰å…¨å¸¦ï¼Œå‡†å¤‡å‡ºå‘ï¼  
è¿„ä»Šä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨å’Œè§£æå™¨ï¼ˆè¯­æ³•åˆ†æå™¨ï¼‰çš„ä»£ç æ˜¯æ··åœ¨ä¸€èµ·çš„ï¼Œåªè¦è§£æå™¨è¯†åˆ«äº†ä¸€ä¸ªç‰¹å®šçš„è¯­æ³•ç»“æ„ï¼ŒåƒåŠ å‡ä¹˜é™¤è¿ç®—ï¼Œé‚£ä¹ˆè§£é‡Šå™¨å°±ä¼šç«‹åˆ»æŠŠå®ƒç»™è®¡ç®—å‡ºæ¥ã€‚è¿™ç§è§£é‡Šå™¨ä¸€èˆ¬è¢«ç§°ä½œ`è¯­æ³•åˆ¶å¯¼`çš„è§£é‡Šå™¨ï¼Œé€šå¸¸åªä¼šå¯¹è¾“å…¥è¿›è¡Œä¸€æ¬¡æ€§çš„å¤„ç†ï¼Œæ¯”è¾ƒé€‚åˆä¸€äº›åŸºç¡€çš„åº”ç”¨ã€‚  
ä¸ºäº†åˆ†æåƒ`PASCAL`è¿™ä¹ˆå¤æ‚çš„è¯­è¨€ç»“æ„ï¼Œæˆ‘ä»¬ä¼šéœ€è¦æ„å»ºä¸€ä¸ªä¸­é—´è¡¨ç¤ºå±‚`intermediate representation (IR)`ã€‚æˆ‘ä»¬çš„è¯­æ³•åˆ†æå™¨å°†ä¼šè´Ÿè´£é€šè¿‡è¯»å–ï¼ˆè¯æ³•åˆ†æå™¨çš„è¾“å‡º`Token`ä½œä¸ºï¼‰è¾“å…¥ï¼Œç„¶åå»æ„å»ºä¸­é—´è¡¨ç¤ºå±‚ï¼Œæœ€åæˆ‘ä»¬çš„è§£é‡Šå™¨å°†ä¼šä½¿ç”¨å¹¶å°†`IR`è§£é‡Šæ‰§è¡Œä¸ºæœ€ç»ˆçš„ç»“æœã€‚  
äº‹å®è¯æ˜æ ‘å½¢çš„æ•°æ®ç»“æ„æ¯”è¾ƒé€‚åˆå»è¡¨ç¤ºä¸­é—´è¡¨ç¤ºå±‚ã€‚
![lsbasi_part7_realtree.png](../_resources/lsbasi_part7_realtree.png)

## æ ‘ä¸è§£ææ ‘

è¿™é‡Œæˆ‘ä»¬å¿«é€Ÿè¿‡ä¸€ä¸‹æ ‘çš„å®šä¹‰ï¼š
1. ä¸€ä¸ªæ ‘é€šå¸¸æœ‰å¾ˆå¤šèŠ‚ç‚¹ï¼ŒæŒ‰ç…§ä¸Šä¸‹çº§çš„å…³ç³»ç»„ç»‡èµ·æ¥  
2. æ¯ä¸ªæ ‘éƒ½ä¼šæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ä½œä¸ºå®ƒæœ€é¡¶å±‚çš„èŠ‚ç‚¹  
3. é™¤æ ¹èŠ‚ç‚¹å¤–ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹  
4. ä¸‹å›¾ä¸­æ ‡æ˜Ÿå·çš„èŠ‚ç‚¹æ˜¯ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œç„¶å2å’Œ7æ˜¯å®ƒçš„å­èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç”±å·¦å‘å³æ’åˆ—  
5. æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ç§°ä¸ºå¶å­èŠ‚ç‚¹  
6. æ ¹èŠ‚ç‚¹å¤–æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹è¢«ç§°ä½œ`å†…éƒ¨èŠ‚ç‚¹ï¼ˆinterior nodeï¼‰`   
7. å­èŠ‚ç‚¹ä¹Ÿå¯ä»¥åŒ…å«ä¸€ä¸ªå®Œæ•´çš„å­æ•°ã€‚åœ¨ä¸‹å›¾ä¸­å·¦è¾¹æ ‡æ˜Ÿå·çš„å­èŠ‚ç‚¹å°±æ˜¯ä¸€ä¸ªå®Œæ•´çš„å­æ•°ï¼Œå› ä¸ºå®ƒæœ‰è‡ªå·±çš„å­èŠ‚ç‚¹2å’Œ7  
8. åœ¨è®¡ç®—æœºå­¦ç§‘ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ä»æ ¹èŠ‚ç‚¹ä½œä¸ºæœ€ä¸Šé¢ï¼Œç„¶åç”±ä¸Šè‡³ä¸‹å»ç»˜åˆ¶å®ƒçš„å­èŠ‚ç‚¹æˆ–è€…æ˜¯åˆ†æ”¯èŠ‚ç‚¹  

ä¸‹é¢æ˜¯ä¸€ä¸ª`2Ã—7+3`è¡¨è¾¾å¼çš„æ ‘çŠ¶ç»“æ„ï¼š
![lsbasi_part7_tree_terminology.png](../_resources/lsbasi_part7_tree_terminology.png)  

æœ¬ç³»åˆ—ä¸­æˆ‘ä»¬ç”¨åˆ°çš„`IR`å°±æ˜¯æŠ½è±¡è¯­æ³•æ ‘ï¼ˆabstract-syntax tree,ASTï¼‰ã€‚ä½†æ˜¯åœ¨æˆ‘ä»¬æ·±ç©¶ASTä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå»ç®€å•äº†è§£ä¸€ä¸‹`è§£ææ ‘ï¼ˆparse treesï¼‰`ã€‚å°½ç®¡åœ¨æˆ‘ä»¬çš„è§£é‡Šå™¨å’Œç¼–è¯‘å™¨ä¸­ä¸ä¼šç”¨åˆ°è§£ææ ‘ï¼Œä½†æ˜¯å®ƒç¡®å®å¯ä»¥ä¸ºæˆ‘ä»¬æä¾›ä¸€ä¸ªå¯è§†åŒ–çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œå¸®æˆ‘ä»¬å»æ›´å¥½çš„ç†è§£æˆ‘ä»¬çš„è§£é‡Šå™¨æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚æˆ‘ä»¬ä¹Ÿä¼šæ¯”è¾ƒå®ƒå’ŒæŠ½è±¡è¯­æ³•æ ‘ï¼Œçœ‹ä¸€ä¸‹ä¸ºä»€ä¹ˆASTæ›´é€‚åˆç”¨æ¥åš`IR`ã€‚  

é‚£ä»€ä¹ˆæ˜¯è§£ææ ‘çš„ï¼Ÿè§£ææ ‘æœ‰æ—¶å€™ä¹Ÿä¼šç§°ä¸º`å…·ä½“è¯­æ³•æ ‘`ï¼Œæ˜¯æ ¹æ®æˆ‘ä»¬çš„è¯­æ³•å®šä¹‰æ„é€ çš„æ•°æ®ç»“æ„ã€‚åŸºæœ¬ä¸Šå®ƒèƒ½å¤Ÿå±•ç¤ºæˆ‘ä»¬çš„è§£æå™¨å¦‚ä½•å»è¯†åˆ«ä¸€ç§è¯­è¨€çš„ç»“æ„ï¼Œæ¢è€Œè¨€ä¹‹ï¼Œå®ƒèƒ½å¤Ÿè¡¨ç¤ºè¯­æ³•ä¸­çš„å¼€å§‹ç¬¦å·æ´¾ç”Ÿå‡ºä¸€ä¸ªç¡®å®šçš„å­—ç¬¦ä¸²ã€‚  

è¯­æ³•åˆ†æå™¨çš„è°ƒç”¨æ ˆå°±å¯ä»¥çœ‹ä½œæˆä¸€ä¸ªè§£ææ ‘ï¼Œå®ƒæ˜¯åœ¨ä½ çš„è¯­æ³•åˆ†æå™¨è¯•å›¾è¯†åˆ«ä¸€ä¸ªç‰¹å®šçš„è¯­è¨€ç»“æ„æ—¶ï¼Œè‡ªåŠ¨åœ¨å†…å­˜ä¸­åˆ›å»ºçš„ã€‚  

è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹è¡¨è¾¾å¼`2Ã—7+3`å¯¹åº”çš„è§£ææ ‘æ˜¯ä»€ä¹ˆæ ·å­çš„ï¼š  
![lsbasi_part7_parsetree_01.png](../_resources/lsbasi_part7_parsetree_01.png) 

ä»ä¸Šå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼š  
1. è§£ææ ‘è®°å½•äº†ä¸€ä¸²è§„åˆ™ã€‚è¯­æ³•åˆ†æå™¨åœ¨è¯†åˆ«è¾“å…¥æ—¶ä¼šç”¨åˆ°ï¼›  
2. è§£ææ ‘çš„æ ¹èŠ‚ç‚¹ç”¨è¯­æ³•çš„èµ·å§‹ç¬¦`expr`æ ‡è®°ï¼ˆè¯·å‚è§`04_ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•`ï¼‰ï¼›  
3. æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹éƒ½è¡¨ç¤ºä¸€ä¸ªéç»ˆæ­¢ç¬¦ï¼Œå®ƒè¡¨ç¤ºç€ä¸€ä¸ªå…·ä½“çš„è¯­æ³•è§„åˆ™ï¼Œåƒ`expr`ã€`term`Â·å’Œ`factor`ï¼›  
4. æ¯ä¸ªå¶å­èŠ‚ç‚¹éƒ½è¡¨ç¤ºä¸€ä¸ª`Token`ã€‚  

ä¹‹å‰è¯´è¿‡ï¼Œæˆ‘ä»¬ä¸ä¼šåœ¨æ–‡ç« ä¸­æ„é€ æˆ–ä½¿ç”¨è§£ææ ‘ï¼Œä½†è§£ææ ‘å¯ä»¥é€šè¿‡å¯è§†åŒ–è°ƒç”¨åºåˆ—æ¥å¸®æˆ‘ä»¬å»äº†è§£è¯­æ³•åˆ†æå™¨æ˜¯å¦‚ä½•è§£é‡Šè¾“å…¥çš„ã€‚

é€šè¿‡ä¸€ä¸ªå°å·¥å…·[genptdot.py](https://github.com/rspivak/lsbasi/blob/master/part7/python/genptdot.py)ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸åŒçš„æ•°å­¦è¡¨è¾¾å¼å¯¹åº”ç€ä¸åŒçš„è§£ææ ‘ã€‚è¿™ä¸ªå°å·¥å…·æ˜¯æˆ‘ä¸“é—¨ä¸ºäº†å¸®åŠ©å¯è§†åŒ–è§£ææ ‘è€Œå¼€å‘çš„ã€‚åœ¨ä½¿ç”¨æ­¤å·¥å…·ä¹‹å‰ï¼Œä½ é¦–å…ˆéœ€è¦å®‰è£…ä¸€ä¸ªå·¥å…·åŒ…[Graphviz](http://graphviz.org/)ï¼Œç„¶åé€šè¿‡è¿è¡Œåé¢çš„è¿™æ¡å‘½ä»¤ï¼Œç”Ÿæˆè§£ææ ‘çš„PNGå›¾ç‰‡ã€‚  
```bash
$ python genptdot.py "14 + 2 * 3 - 6 / 2" > \
  parsetree.dot && dot -Tpng -o parsetree.png parsetree.dot
```

ä¸‹é¢æ˜¯`14+2Ã—3-6Ã·2`æ‰€å¯¹åº”çš„è§£ææ ‘ï¼š 
![lsbasi_part7_genptdot_01.png](../_resources/lsbasi_part7_genptdot_01.png)  

é€šè¿‡å¤šä¼ å…¥å‡ ä¸ªè¡¨è¾¾å¼ï¼Œçœ‹ä¸€ä¸‹æ¯ä¸ªè¡¨è¾¾å¼æ‰€å¯¹åº”çš„è§£ææ ‘æœ‰ä»€ä¹ˆä¸åŒã€‚  

## æŠ½è±¡è¯­æ³•æ ‘  

ç°åœ¨æˆ‘ä»¬å¼€å§‹è®²ä¸€ä¸‹æŠ½è±¡è¯­æ³•æ ‘ASTï¼Œè¿™ä¸ª`IR`å°†ä¼šåœ¨æˆ‘ä»¬åé¢çš„ç³»åˆ—ä¸­é¢‘ç¹ç”¨åˆ°ï¼Œå¯¹æˆ‘ä»¬çš„è§£é‡Šå™¨å’Œæœªæ¥çš„ç¼–è¯‘å™¨é¡¹ç›®æ¥è¯´éƒ½æ˜¯ä¸€ä¸ªéå¸¸æ ¸å¿ƒçš„æ•°æ®ç»“æ„ã€‚  

è®©æˆ‘ä»¬å¯¹ç…§`2Ã—7+3`å¯¹åº”çš„ASTå’Œè§£ææ ‘ï¼Œæ¥çœ‹ä¸€ä¸‹äºŒè€…æœ‰ä½•ä¸åŒï¼š  
![lsbasi_part7_ast_01.png](../_resources/lsbasi_part7_ast_01.png)  
æ­£å¦‚ä¸Šå›¾æ‰€ç¤ºï¼ŒæŠ½è±¡è¯­æ³•æ ‘æ›´èƒ½æŠ“ä½è¾“å…¥çš„ç²¾é«“ï¼Œæ‰€ä»¥å®ƒçš„æ•°æ®ç»“æ„ä¼šæ›´ç´§å‡‘ä¸€äº›ã€‚  
ä¸‹é¢æ˜¯ä¸€äº›æŠ½è±¡è¯­æ³•æ ‘å’Œè§£ææ ‘çš„ä¸åŒï¼š  
1. æŠ½è±¡è¯­æ³•æ ‘ä½¿ç”¨è¿ç®—ç¬¦ä½œä¸ºæ ¹èŠ‚ç‚¹æˆ–å†…éƒ¨èŠ‚ç‚¹ï¼Œç„¶åä½¿ç”¨æ“ä½œæ•°ä½œä¸ºä»–ä»¬çš„å­èŠ‚ç‚¹ï¼›  
2. æŠ½è±¡è¯­æ³•æ ‘å¹¶ä¸ä¼šä½¿ç”¨è¯­æ³•è§„åˆ™ä½œä¸ºå®ƒçš„å†…éƒ¨èŠ‚ç‚¹ï¼›  
3. æŠ½è±¡è¯­æ³•æ ‘å¹¶ä¸ä¼šè¡¨ç¤ºæ¯ä¸€ä¸ªè¯­æ³•ç»†èŠ‚ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå®ƒè¢«å«åš`æŠ½è±¡`è¯­æ³•æ ‘çš„åŸå› ã€‚æ²¡æœ‰è§„åˆ™çš„èŠ‚ç‚¹ï¼Œä¹Ÿæ²¡æœ‰æ‹¬å·ï¼›  
4. æŠ½è±¡è¯­æ³•æ ‘ç›¸è¾ƒäºè§£ææ ‘ï¼Œç»“æ„æ›´ç´§å¯†ã€‚  

æ‰€ä»¥ä»€ä¹ˆæ˜¯æŠ½è±¡è¯­æ³•æ ‘ï¼ŸæŠ½è±¡è¯­æ³•æ ‘ASTå°±æ˜¯ä¸€ä¸ªæ•°ç»“æ„ï¼Œç”¨æ¥è¡¨ç¤ºä¸€ç§è¯­è¨€çš„æŠ½è±¡è¯­æ³•ç»“æ„ã€‚å®ƒçš„æ ¹èŠ‚ç‚¹å’Œå†…éƒ¨èŠ‚ç‚¹éƒ½æ˜¯ä»£è¡¨ç€ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œæ¯ä¸ªå¶å­èŠ‚ç‚¹ç›¸å½“äºä¸€ä¸ªæ“ä½œæ•°ã€‚

å‰é¢æåˆ°è¿‡ASTå¹¶ä¸ä¼šåƒè§£ææ ‘é‚£ä¹ˆåºå¤§ï¼Œä¸‹é¢è®©æˆ‘ä»¬æ¯”è¾ƒä¸€ä¸‹`7 + ((2 + 3))`å¯¹åº”çš„ASTå’Œè§£ææ ‘ï¼Œä½ å¯ä»¥çœ‹åˆ°ASTéå¸¸ç´§å‡‘ï¼Œä½†æ˜¯å´èƒ½æ¶µç›–è¾“å…¥æ‰€æœ‰çš„è¦ç‚¹ã€‚  
![lsbasi_part7_ast_02.png](../_resources/lsbasi_part7_ast_02.png)  

çœ‹èµ·æ¥è¿˜ä¸é”™ï¼Œä½†æ˜¯æˆ‘ä»¬è¯¥å¦‚ä½•è¡¨ç¤ºæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Ÿæ¯”æ–¹xè¦å…ˆäºyè¿ç®—ï¼Œé‚£æˆ‘ä»¬å°±åªéœ€å°†xæ”¾åˆ°æ¯”yæ›´ä½å±‚çš„èŠ‚ç‚¹ä¸­å°±å¯ä»¥äº†ã€‚è¿™åœ¨ä¹‹å‰çš„ä¾‹å­ä¸­ä¹Ÿèƒ½çœ‹å¾—å‡ºæ¥ã€‚  

è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å…¶ä»–ä¾‹å­ã€‚ä¸‹å›¾çš„å·¦ä¾§æ˜¯`2Ã—7+3`çš„ASTï¼Œä½†å¦‚æœæˆ‘ä»¬æƒ³è¦é€šè¿‡æ‹¬å·æŠŠ7+3çš„ä¼˜å…ˆçº§æé«˜ä¸€äº›ï¼Œä½ å¯ä»¥çœ‹åˆ°å³ä¾§ä¿®æ”¹åçš„`2Ã—(7+3)`çš„ASTã€‚
![lsbasi_part7_astprecedence_01.png](../_resources/lsbasi_part7_astprecedence_01.png)  

ä¸‹é¢æ˜¯è¡¨è¾¾å¼`1+2+3+4+5`çš„ASTã€‚  
![lsbasi_part7_astprecedence_02.png](../_resources/lsbasi_part7_astprecedence_02.png)  
ä»ä¸Šå›¾å°±å¯ä»¥çœ‹åˆ°è¶Šé«˜ä¼˜å…ˆçº§çš„è¿ç®—ç¬¦åœ¨æ ‘ç»“æ„çš„ä½ç½®å°±è¶Šé ä¸‹ã€‚  

ç°åœ¨æˆ‘ä»¬å¼€å§‹ç”¨ä»£ç å®ç°ä¸åŒçš„ASTèŠ‚ç‚¹ï¼Œç„¶åä¿®æ”¹æˆ‘ä»¬çš„è¯­æ³•åˆ†æå™¨æ¥ç”Ÿæˆä¸€ä¸ªASTã€‚  

é¦–å…ˆæ˜¯åˆ›å»ºä¸€ä¸ªASTçš„åŸºç±»ï¼Œå…¶ä»–èŠ‚ç‚¹ç±»éƒ½ä¼šé›†æˆå®ƒï¼š  
```python
class AST(object):
    pass
```

æ²¡æœ‰å¤ªå¤šä¸œè¥¿,å›æƒ³ä¸€ä¸‹ASTè¡¨ç¤ºçš„æ˜¯`è¿ç®—ç¬¦-æ“ä½œæ•°`çš„æ¨¡å‹ã€‚ç›®å‰ä¸ºæ­¢æˆ‘ä»¬å·²ç»æœ‰4ä¸ªè¿ç®—ç¬¦ï¼ˆåŠ å‡ä¹˜é™¤ï¼‰å’Œ1ä¸ªæ•´æ•°æ“ä½œæ•°ã€‚è™½ç„¶æˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸€ä¸ªè¿ç®—ç¬¦åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹ç±»ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸ä¼šè¿™æ ·åšï¼Œæˆ‘ä»¬å°†ä¼šæå–å®ƒä»¬çš„ç‰¹å¾åˆ›å»ºä¸€ä¸ª`äºŒå…ƒè¿ç®—ç¬¦`ç±»`BinOp`ã€‚  
```python
class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right
```

`BinOp`çš„æ„é€ å‡½æ•°æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼š`left`è¿ç®—ç¬¦å·¦ä¾§çš„èŠ‚ç‚¹ï¼›`right`è¿ç®—ç¬¦å³ä¾§çš„èŠ‚ç‚¹ï¼›`op`è¡¨ç¤ºè¿ç®—ç¬¦æœ¬èº«ï¼Œä¾‹å¦‚ï¼š`Token(PLUS,'+')`ã€‚  
ä¸ºäº†åœ¨ASTä¸­è¡¨ç¤ºæ•´æ•°ï¼Œæˆ‘ä»¬éœ€è¦æ„å»ºä¸€ä¸ªæ•°å€¼ç±»å‹`Num`ï¼Œç”¨äºä¿å­˜ä¸€ä¸ªæ•´æ•°çš„tokenå’Œå®ƒçš„å€¼ï¼š  
```python
class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value
```

ä¹Ÿè®¸ä½ å·²ç»æ³¨æ„åˆ°æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½ä¼šä¿å­˜ä¸€ä¸ªtokenï¼Œè¿™æ ·å¯¹æˆ‘ä»¬å°†æ¥çš„æ“ä½œçš„è¯ä¼šæœ‰æå¤§çš„æ–¹ä¾¿æ€§ã€‚  
å›å¿†ä¸€ä¸‹æˆ‘ä»¬ä¹‹å‰çš„è¡¨è¾¾æ˜¯`2Ã—7+3`ï¼Œæˆ‘ä»¬å°†ä¼šæ‰‹å·¥æ„é€ å®ƒçš„ASTï¼š
```bash
>>> from spi import Token, MUL, PLUS, INTEGER, Num, BinOp
>>>
>>> mul_token = Token(MUL, '*')
>>> plus_token = Token(PLUS, '+')
>>> mul_node = BinOp(
...     left=Num(Token(INTEGER, 2)),
...     op=mul_token,
...     right=Num(Token(INTEGER, 7))
... )
>>> add_node = BinOp(
...     left=mul_node,
...     op=plus_token,
...     right=Num(Token(INTEGER, 3))
... )
```

ä»¥ä¸Šå°±æ˜¯å¦‚ä½•å®šä¹‰ASTçš„èŠ‚ç‚¹ï¼Œä¸‹å›¾æ˜¯æ‰‹å·¥å®šä¹‰ASTèŠ‚ç‚¹çš„è¿‡ç¨‹ï¼š
![lsbasi_part7_astimpl_01.png](../_resources/lsbasi_part7_astimpl_01.png)  

ä¸‹é¢æ˜¯æˆ‘ä»¬ä¿®æ”¹åçš„è§£é‡Šå™¨çš„ä»£ç ï¼Œé€šè¿‡è¯†åˆ«ä¸€ä¸ªç®—æœ¯è¡¨è¾¾å¼çš„è¾“å…¥ï¼Œæ„é€ å¹¶è¿”å›ä¸€ä¸ªASTã€‚  
```python
class AST(object):
    pass


class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right


class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value


class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        # set current token to the first token taken from the input
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')

    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then "eat" the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    def factor(self):
        """factor : INTEGER | LPAREN expr RPAREN"""
        token = self.current_token
        if token.type == INTEGER:
            self.eat(INTEGER)
            return Num(token)
        elif token.type == LPAREN:
            self.eat(LPAREN)
            node = self.expr()
            self.eat(RPAREN)
            return node

    def term(self):
        """term : factor ((MUL | DIV) factor)*"""
        node = self.factor()

        while self.current_token.type in (MUL, DIV):
            token = self.current_token
            if token.type == MUL:
                self.eat(MUL)
            elif token.type == DIV:
                self.eat(DIV)

            node = BinOp(left=node, op=token, right=self.factor())

        return node

    def expr(self):
        """
        expr   : term ((PLUS | MINUS) term)*
        term   : factor ((MUL | DIV) factor)*
        factor : INTEGER | LPAREN expr RPAREN
        """
        node = self.term()

        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            if token.type == PLUS:
                self.eat(PLUS)
            elif token.type == MINUS:
                self.eat(MINUS)

            node = BinOp(left=node, op=token, right=self.term())

        return node

    def parse(self):
        return self.expr()
```

è®©æˆ‘ä»¬é€šè¿‡ä¸€äº›ä¾‹å­æ¥å›é¡¾ä¸€ä¸‹ASTçš„æ„é€ è¿‡ç¨‹ã€‚æ¯ä¸€ä¸ª`BinOp`çš„èŠ‚ç‚¹ï¼Œéƒ½ä¼šæ¥å—ä¸€ä¸ª`left`èŠ‚ç‚¹å’Œä¸€ä¸ª`op`èŠ‚ç‚¹ï¼Œå¹¶æŠŠè‡ªå·±ä½œä¸º`left`èŠ‚ç‚¹ä¼ é€’ç»™ä¸‹ä¸€ä¸ª`BinOp`ï¼Œä»¥æ­¤ç±»æ¨ã€‚
![lsbasi_part7_astimpl_02.png](../_resources/lsbasi_part7_astimpl_02.png)  

ä¸ºäº†å¸®åŠ©ä½ æ›´å¥½çš„çœ‹è§‚å¯Ÿä¸åŒè¡¨è¾¾å¼çš„ASTï¼Œæˆ‘è¿˜å†™äº†ä¸€ä¸ªå°å·¥å…·ï¼Œå¯ä»¥å°†ä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°è¾“å…¥ï¼Œç„¶åç”Ÿæˆä¸€ä¸ª`dot`æ–‡ä»¶ã€‚è¿™ä¸ªæ–‡ä»¶ä¼šé€šè¿‡`dot`å·¥å…·ï¼ˆGraphvizçš„ä¸€éƒ¨åˆ†ï¼‰å¤„ç†ï¼Œç„¶åç»˜åˆ¶å‡ºä¸€ä¸ªæŠ½è±¡è¯­æ³•æ ‘ã€‚ä¾‹å¦‚ç»˜åˆ¶`7 + 3 * (10 / (12 / (3 + 1) - 1))`çš„ASTï¼š
```bash
$ python genastdot.py "7 + 3 * (10 / (12 / (3 + 1) - 1))" > \
  ast.dot && dot -Tpng -o ast.png ast.dot
```
![lsbasi_part7_genastdot_01.png](../_resources/lsbasi_part7_genastdot_01.png)  

æˆ‘ä»¬å¯ä»¥å¤šå†™ä¸€äº›ç®—æœ¯è¡¨è¾¾å¼ï¼Œç„¶åæ‰‹å·¥å»æ„å»ºASTå¹¶å’Œè‡ªåŠ¨ç”Ÿæˆçš„ç»“æœå¯¹æ¯”ï¼Œè¿™æ ·çš„è¯å°±å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ›´å¥½çš„å»ç†è§£ASTçš„å·¥ä½œåŸç†ã€‚ä¸‹é¢å°±æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼`2 * 7 + 3`çš„ä¾‹å­ï¼š
![lsbasi_part7_ast_walking_01.png](../_resources/lsbasi_part7_ast_walking_01.png)  

## éå†AST  

æˆ‘ä»¬å¦‚ä½•å»å®šä½ASTä¸­çš„è¡¨è¾¾å¼ï¼Œä»¥ä¾¿èƒ½å¤Ÿè®¡ç®—å‡ºæ­£ç¡®çš„ç»“æœã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©é€šè¿‡`ååºéå†ï¼ˆpostorder traversalï¼‰`ï¼Œè¿™æ˜¯ä¸€ç§ç‰¹æ®Šçš„`æ·±åº¦ä¼˜å…ˆï¼ˆdepth-firstï¼‰`éå†ç­–ç•¥ï¼šä»æ ¹ç»“ç‚¹å¼€å§‹ï¼Œä¾æ¬¡é€’å½’åœ°éå†æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿œç¦»æ ¹èŠ‚ç‚¹çš„èŠ‚ç‚¹å°†ä¼šè¢«ä¼˜å…ˆè®¿é—®åˆ°ã€‚åœ¨æˆ‘ä»¬ä¸Šé¢æåˆ°è¿‡ï¼Œè¶Šæ˜¯è¿œç¦»æ ¹èŠ‚ç‚¹çš„è¯ï¼Œå°±è¯æ˜è®¡ç®—çš„ä¼˜å…ˆçº§è¶Šé«˜ï¼Œè¿™ä¹Ÿç¬¦åˆæˆ‘ä»¬çš„è¦æ±‚ã€‚

ä¸‹å›¾æ˜¯ååºéå†çš„ä¼ªä»£ç ï¼Œå ä½ç¬¦`<<postorder actions>>`ç”¨æ¥æ¥è¡¨ç¤ºåŠ å‡ä¹˜é™¤è¿™æ ·çš„è®¡ç®—è¡Œä¸ºï¼Œæˆ–è€…æ˜¯è¿”å›æ•´æ•°çš„è¡Œä¸ºã€‚å¯¹ï¼Œè¦ä¹ˆå°±æ˜¯è¿”å›æ•´æ•°æœ¬èº«ï¼Œè¦ä¹ˆå°±æ˜¯è¿”å›åŠ å‡è¿ç®—ä¹‹åçš„ç»“æœã€‚  
![lsbasi_part7_ast_visit_postorder.png](../_resources/lsbasi_part7_ast_visit_postorder.png) 

æœ‰ä¸¤ç‚¹åŸå› ï¼Œæˆ‘ä»¬ä¼šè®©æˆ‘ä»¬å»é€‰æ‹©ååºéå†ï¼šé¦–å…ˆæˆ‘ä»¬éœ€è¦å»ç¡®å®šåœ¨è®¡ç®—å†…éƒ¨èŠ‚ç‚¹æ—¶çš„ä¼˜å…ˆçº§ï¼Œè¶Šæ˜¯è¿œç¦»æ ¹èŠ‚ç‚¹çš„ä¼˜å…ˆçº§å°±è¶Šé«˜ï¼›ç„¶åæˆ‘ä»¬éœ€è¦åœ¨åœ¨ä½¿ç”¨ä¸€ä¸ªèŠ‚ç‚¹ä¹‹å‰ï¼Œè¦å…ˆå»ç®—å‡ºè¯¥èŠ‚ç‚¹çš„å€¼ï¼Œç„¶åå†æŠŠå®ƒç”¨åˆ°æ–°çš„è¿ç®—ä¸­å»ã€‚ä¸‹å›¾ä¸­æˆ‘ä»¬é‡‡ç”¨ååºéå†ï¼Œé¦–å…ˆè®¡ç®—å‡º`2+7=14`ï¼Œç„¶åå†å»ç®—`14+3=17`ã€‚  
![lsbasi_part7_ast_walking_02.png](../_resources/lsbasi_part7_ast_walking_02.png) 

å®Œæ•´èµ·è§ï¼Œè¿™é‡Œç®€å•ä»‹ç»ä¸‰ç§ä¸åŒçš„æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•ï¼šå‰åºéå†ã€ä¸­åºéå†å’Œååºéå†ã€‚é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯çœ‹ä¸€ä¸‹ä½ åœ¨ä»£ç ä¸­ä»€ä¹ˆä½ç½®æ’å…¥actionè¡Œä¸ºã€‚  
![lsbasi_part7_ast_visit_generic.png](../_resources/lsbasi_part7_ast_visit_generic.png) 

æœ‰æ—¶æˆ‘ä»¬éœ€è¦åŒæ—¶ç”¨åˆ°ä¸‰ç§éå†ç­–ç•¥ã€‚ä½ ä¹Ÿä¼šåœ¨æºç ä¸­çœ‹åˆ°ç›¸å…³çš„ä¾‹å­ã€‚

OKï¼Œç°åœ¨æˆ‘ä»¬ç”¨pythonä»£ç å»éå†è¯­æ³•åˆ†æå™¨ç”Ÿæˆçš„ASTã€‚ä¸‹é¢æ˜¯å®ç°äº†è®¿é—®è€…æ¨¡å¼çš„æºä»£ç ï¼š
```python
class NodeVisitor(object):
    def visit(self, node):
        # è¿™é‡Œç”¨æ–¹æ³•åå–ä»£äº†å¾ˆå¤šif æ¡ä»¶è¯­å¥
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception('No visit_{} method'.format(type(node).__name__))
```

ä¸‹é¢æ˜¯æˆ‘ä»¬è§£é‡Šå™¨çš„æºä»£ç ï¼Œå®ƒç»§æ‰¿è‡ª`NodeVisitor`ç±»å¹¶å®ç°äº†ä¸åŒçš„`visit_NodeType`æ–¹æ³•ï¼Œå…¶ä¸­`NodeType`è¢«æ›¿æ¢ä¸ºèŠ‚ç‚¹çš„ç±»åï¼Œå¦‚ `BinOp`ã€`Num` ç­‰ã€‚
```python
class Interpreter(NodeVisitor):
    def __init__(self, parser):
        self.parser = parser

    def visit_BinOp(self, node):
        if node.op.type == PLUS:
            return self.visit(node.left) + self.visit(node.right)
        elif node.op.type == MINUS:
            return self.visit(node.left) - self.visit(node.right)
        elif node.op.type == MUL:
            return self.visit(node.left) * self.visit(node.right)
        elif node.op.type == DIV:
            return self.visit(node.left) / self.visit(node.right)

    def visit_Num(self, node):
        return node.value
```

è¿™é‡Œä»£ç æœ‰ä¸¤ä¸ªæœ‰è¶£çš„åœ°æ–¹å€¼å¾—ä¸€æï¼šé¦–å…ˆéå†æ–¹æ³•ä¸ASTæ•°æ®æ˜¯è§£è€¦çš„ï¼Œå¯ä»¥çœ‹åˆ°ASTèŠ‚ç‚¹æœ¬èº«æ²¡æœ‰æä¾›ä»»ä½•ä»£ç æ¥è®¿é—®è‡ªèº«çš„æ•°æ®ï¼Œè¯¥é€»è¾‘è¢«å°è£…åœ¨`NodeVisitor`ç±»ä¸­ï¼›å…¶æ¬¡æ˜¯é‡‡ç”¨æ–¹æ³•åå–ä»£å¾ˆå¤šifè¯­å¥ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§å¸¸ç”¨çš„è®¾è®¡æ€ç»´ï¼Œä¾‹å¦‚ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨æ–¹æ³•ç­‰ã€‚
```python
def visit(node):
    node_type = type(node).__name__
    if node_type == 'BinOp':
        return self.visit_BinOp(node)
    elif node_type == 'Num':
        return self.visit_Num(node)
    elif ...
    # ...

#### æˆ–è€…æ˜¯ ####

def visit(node):
    if isinstance(node, BinOp):
        return self.visit_BinOp(node)
    elif isinstance(node, Num):
        return self.visit_Num(node)
    elif ...
```

`NodeVisitor`çš„`visit`æ–¹æ³•éå¸¸é€šç”¨ï¼Œä¸”èƒ½å¤Ÿæ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹ç±»å‹è°ƒç”¨å¯¹åº”çš„æ–¹æ³•ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€è¯´ï¼Œä¸ºäº†å……åˆ†åˆ©ç”¨å®ƒï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨ç»§æ‰¿äº†`NodeVisitor`ç±»å¹¶å®ç°äº†å…³é”®çš„æ–¹æ³•ã€‚æ‰€ä»¥å¦‚æœä¼ é€’ç»™`visit`çš„çš„èŠ‚ç‚¹ç±»å‹æ˜¯`BinOp`ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šè°ƒç”¨`visit_BinOp()`ï¼›å¦‚æœèŠ‚ç‚¹ç±»å‹æ˜¯æ•´æ•°ï¼Œå®ƒå°±ä¼šè°ƒç”¨`visit_Num()`ã€‚  

åœ¨è¿™é‡Œå¯ä»¥å¤šèŠ±ä¸€äº›æ—¶é—´å»è¯¦ç»†äº†è§£å…¶å®ç°åŸç†ã€‚äº‹å®ä¸Šæ ‡å‡†çš„Python aståº“ä¹Ÿæ˜¯ç”¨åŒæ ·çš„æœºåˆ¶å»å®ç°çš„ã€‚æˆ‘ä»¬åœ¨ä»¥åå°†ä¼šæ‰©å±•æ›´å¤šçš„èŠ‚ç‚¹ç±»å‹ã€‚ï¼ˆè¯‘æ³¨ï¼šåœ¨è„šæœ¬è¯­è¨€ä¸­å¯ä»¥è¿™æ ·ç”¨ï¼Œä½†æ˜¯åœ¨ç¼–è¯‘å‹è¯­è¨€ä¸­éœ€è¦ç”¨`map`æˆ–`hashmap`å»å­˜å‚¨å‡½æ•°åï¼‰`generic_visit`æ–¹æ³•æ˜¯ä¸€ä¸ªå¼‚å¸¸å¤„ç†æ–¹æ³•ï¼Œå¦‚æœé‡åˆ°ä¸€ä¸ªä¸èƒ½æ­£ç¡®åŒ¹é…çš„èŠ‚ç‚¹ç±»å‹çš„è¯ï¼Œå°±ä¼šè°ƒç”¨è¯¥æ–¹æ³•äº§ç”Ÿä¸€ä¸ªå¼‚å¸¸ã€‚

å¥½å§ï¼Œç°åœ¨è®©æˆ‘ä»¬æ‰‹å·¥å»æ„å»º`2 * 7 + 3`çš„ASTï¼Œå¹¶æŠŠå®ƒä¼ è¿›è§£é‡Šï¼Œçœ‹èƒ½ä¸èƒ½æ­£å¸¸è¿è¡Œã€‚   
```bash
>>> from spi import Token, MUL, PLUS, INTEGER, Num, BinOp
>>>
>>> mul_token = Token(MUL, '*')
>>> plus_token = Token(PLUS, '+')
>>> mul_node = BinOp(
...     left=Num(Token(INTEGER, 2)),
...     op=mul_token,
...     right=Num(Token(INTEGER, 7))
... )
>>> add_node = BinOp(
...     left=mul_node,
...     op=plus_token,
...     right=Num(Token(INTEGER, 3))
... )
>>> from spi import Interpreter
>>> inter = Interpreter(None)
>>> inter.visit(add_node)
17
```

å¦‚ä½ æ‰€è§ï¼Œæˆ‘æŠŠæ ¹ç»“ç‚¹ä¼ åˆ°`visit`æ–¹æ³•ä¹‹åï¼Œä¾¿è§¦å‘äº†éå†è¿‡ç¨‹ï¼Œé€šè¿‡è°ƒç”¨ä¸€ç³»åˆ—çš„å‡½æ•°ï¼Œæœ€åè·å¾—äº†ä¸€ä¸ªæ­£ç¡®çš„è®¡ç®—ç»“æœã€‚ä»¥ä¸‹æ˜¯å®Œæ•´çš„æºä»£ç ä¾›ä½ å‚è€ƒï¼š  
```python
""" SPI - Simple Pascal Interpreter """

###############################################################################
#                                                                             #
#  LEXER                                                                      #
#                                                                             #
###############################################################################

# Token types
#
# EOF (end-of-file) token is used to indicate that
# there is no more input left for lexical analysis
INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (
    'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF'
)


class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        """String representation of the class instance.

        Examples:
            Token(INTEGER, 3)
            Token(PLUS, '+')
            Token(MUL, '*')
        """
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()


class Lexer(object):
    def __init__(self, text):
        # client string input, e.g. "4 + 2 * 3 - 6 / 2"
        self.text = text
        # self.pos is an index into self.text
        self.pos = 0
        self.current_char = self.text[self.pos]

    def error(self):
        raise Exception('Invalid character')

    def advance(self):
        """Advance the `pos` pointer and set the `current_char` variable."""
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # Indicates end of input
        else:
            self.current_char = self.text[self.pos]

    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def integer(self):
        """Return a (multidigit) integer consumed from the input."""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def get_next_token(self):
        """Lexical analyzer (also known as scanner or tokenizer)

        This method is responsible for breaking a sentence
        apart into tokens. One token at a time.
        """
        while self.current_char is not None:

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char == '+':
                self.advance()
                return Token(PLUS, '+')

            if self.current_char == '-':
                self.advance()
                return Token(MINUS, '-')

            if self.current_char == '*':
                self.advance()
                return Token(MUL, '*')

            if self.current_char == '/':
                self.advance()
                return Token(DIV, '/')

            if self.current_char == '(':
                self.advance()
                return Token(LPAREN, '(')

            if self.current_char == ')':
                self.advance()
                return Token(RPAREN, ')')

            self.error()

        return Token(EOF, None)


###############################################################################
#                                                                             #
#  PARSER                                                                     #
#                                                                             #
###############################################################################

class AST(object):
    pass


class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right


class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value


class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        # set current token to the first token taken from the input
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')

    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then "eat" the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    def factor(self):
        """factor : INTEGER | LPAREN expr RPAREN"""
        token = self.current_token
        if token.type == INTEGER:
            self.eat(INTEGER)
            return Num(token)
        elif token.type == LPAREN:
            self.eat(LPAREN)
            node = self.expr()
            self.eat(RPAREN)
            return node

    def term(self):
        """term : factor ((MUL | DIV) factor)*"""
        node = self.factor()

        while self.current_token.type in (MUL, DIV):
            token = self.current_token
            if token.type == MUL:
                self.eat(MUL)
            elif token.type == DIV:
                self.eat(DIV)

            node = BinOp(left=node, op=token, right=self.factor())

        return node

    def expr(self):
        """
        expr   : term ((PLUS | MINUS) term)*
        term   : factor ((MUL | DIV) factor)*
        factor : INTEGER | LPAREN expr RPAREN
        """
        node = self.term()

        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            if token.type == PLUS:
                self.eat(PLUS)
            elif token.type == MINUS:
                self.eat(MINUS)

            node = BinOp(left=node, op=token, right=self.term())

        return node

    def parse(self):
        return self.expr()


###############################################################################
#                                                                             #
#  INTERPRETER                                                                #
#                                                                             #
###############################################################################

class NodeVisitor(object):
    def visit(self, node):
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception('No visit_{} method'.format(type(node).__name__))


class Interpreter(NodeVisitor):
    def __init__(self, parser):
        self.parser = parser

    def visit_BinOp(self, node):
        if node.op.type == PLUS:
            return self.visit(node.left) + self.visit(node.right)
        elif node.op.type == MINUS:
            return self.visit(node.left) - self.visit(node.right)
        elif node.op.type == MUL:
            return self.visit(node.left) * self.visit(node.right)
        elif node.op.type == DIV:
            return self.visit(node.left) / self.visit(node.right)

    def visit_Num(self, node):
        return node.value

    def interpret(self):
        tree = self.parser.parse()
        return self.visit(tree)


def main():
    while True:
        try:
            try:
                text = raw_input('spi> ')
            except NameError:  # Python3
                text = input('spi> ')
        except EOFError:
            break
        if not text:
            continue

        lexer = Lexer(text)
        parser = Parser(lexer)
        interpreter = Interpreter(parser)
        result = interpreter.interpret()
        print(result)


if __name__ == '__main__':
    main()
```

å°†ä¸‹é¢çš„æ–‡ä»¶ä¿å­˜ä¸º`spi.py`æˆ–è€…æ˜¯ç›´æ¥ä»[github](https://github.com/rspivak/lsbasi/blob/master/part7/python/spi.py)ä¸Šé¢ä¸‹è½½ï¼Œç„¶åå°è¯•è¿è¡Œä¸€ä¸‹ï¼š  
```bash
$ python spi.py
spi> 7 + 3 * (10 / (12 / (3 + 1) - 1))
22
spi> 7 + 3 * (10 / (12 / (3 + 1) - 1)) / (2 + 3) - 5 - 3 + (8)
10
spi> 7 + (((3 + 2)))
12
```

ä»Šå¤©æˆ‘ä»¬å­¦ä¹ äº†è§£ææ ‘ã€ASTã€ä»¥åŠå¦‚ä½•æ„é€ å¹¶éå†ASTã€‚æˆ‘ä»¬ä¹Ÿå·²ç»å°†æˆ‘ä»¬çš„è¯­æ³•åˆ†æå™¨å’Œè§£é‡Šå™¨è§£è€¦å¼€æ¥ï¼Œç°åœ¨å®ƒä»¬çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š  
![lsbasi_part7_pipeline.png](../_resources/lsbasi_part7_pipeline.png) 
å¯ä»¥è¯´æ˜¯è¯­æ³•åˆ†æå™¨`parser`é€šè¿‡è·å–å¹¶å¤„ç†è¯æ³•åˆ†æå™¨`lexer`äº§ç”Ÿçš„`token`ï¼Œè¿”å›ä¸€ä¸ªASTç»™è§£é‡Šå™¨`interpreter`ï¼Œç„¶åè§£é‡Šå™¨é€šè¿‡ååºéå†è§£é‡Šæ‰§è¡Œã€‚

ä»¥ä¸Šå°±æ˜¯ä»Šå¤©çš„å…¨éƒ¨å†…å®¹ï¼Œä½†æ˜¯åœ¨ç»“æŸä¹‹å‰æˆ‘è¿˜æƒ³ç®€å•è¯´ä¸€ä¸‹é€’å½’ä¸‹é™çš„è§£é‡Šå™¨ã€‚ä»åå­—å¯ä»¥çœ‹å‡ºï¼Œé€’å½’ä¸‹é™çš„è§£é‡Šå™¨æ˜¯ä¸€ä¸ªè‡ªä¸Šå‘ä¸‹çš„è§£é‡Šå™¨ï¼Œé€šè¿‡ä¸€ç³»åˆ—çš„é€’å½’è°ƒç”¨è¿‡ç¨‹æ¥å¤„ç†è¾“å…¥ï¼Œè‡ªä¸Šå‘ä¸‹å°±åæ˜ äº†è¿™ä¸ªè§£é‡Šå™¨ä¼šé¦–å…ˆæ„é€ ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œç„¶åå†å»æ„é€ æ›´ä½çº§çš„å­èŠ‚ç‚¹ã€‚

ä¸‹é¢æ˜¯ç»ƒä¹ æ—¶é—´ï¼š  
![lsbasi_part7_exercise.png](../_resources/lsbasi_part7_exercise.png)   
- ç¼–å†™ä¸€ä¸ªè§£é‡Šå™¨ï¼Œå°†ç®—æœ¯è¡¨è¾¾å¼ä½œä¸ºè¾“å…¥å¹¶ä»¥`åå‘æ³¢å…°è¡¨ç¤ºæ³•ï¼ˆRPNï¼‰`æ‰“å°ã€‚å¦‚ï¼šè¾“å…¥`(5 + 3) * 12 / 3`ï¼Œè¾“å‡º`5 3 + 12 * 3 /`  
- ç¼–å†™ä¸€ä¸ªè§£é‡Šå…¶ï¼Œå°†ç®—æœ¯è¡¨è¾¾å¼ä½œä¸ºè¾“å…¥å¹¶ä»¥`LISP`è¯­æ³•æ‰“å°ã€‚å¦‚ï¼šè¾“å…¥`(2 + 3 * 5)`ï¼Œè¾“å‡º`(+ 2 (* 3 5))`  

ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šä¸ºæˆ‘ä»¬çš„`PASCAL`è§£é‡Šå™¨æ·»åŠ èµ‹å€¼è¯­å¥å’Œä¸€å…ƒè¿ç®—ç¬¦ï¼Œæ•¬è¯·æœŸå¾…ã€‚  

PSï¼šæœ¬ç« çš„ä»£ç æˆ‘è¿˜æä¾›äº†è§£é‡Šå™¨çš„`Rust`å®ç°ï¼Œä½ å¯ä»¥åœ¨GitHubä¸Šæ‰¾åˆ°ã€‚è¿™ä¹Ÿæ˜¯æˆ‘å­¦ä¹ `Rust`ç¼–ç¨‹è¯­è¨€çš„ä¸€ç§æ–¹å¼ï¼Œä½†è¯·æ³¨æ„ï¼Œä»£ç é£æ ¼å¯èƒ½è¿˜ä¸æ˜¯`æƒ¯ç”¨çš„`ã€‚ æ€»ä¹‹æ¬¢è¿æœ‰å…³å¦‚ä½•ä½¿ä»£ç æ›´å¥½çš„è¯„è®ºå’Œå»ºè®®ã€‚


ä»¥ä¸‹ä¹¦ç±å¯èƒ½ä¼šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š  

1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](http://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)  
2. [Writing Compilers and Interpreters: A Software Engineering Approach](http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=UCLGQTPIYSWYKRRM)  
3. [Modern Compiler Implementation in Java](http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=052182060X&linkCode=as2&tag=russblo0b-20&linkId=ZSKKZMV7YWR22NMW)  
4. [Modern Compiler Design](http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1461446988&linkCode=as2&tag=russblo0b-20&linkId=PAXWJP5WCPZ7RKRD)  
5. [Compilers: Principles, Techniques, and Tools (2nd Edition)](http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321486811&linkCode=as2&tag=russblo0b-20&linkId=GOEGDQG4HIHU56FQ)   

-----  
2021-01-09 17:20